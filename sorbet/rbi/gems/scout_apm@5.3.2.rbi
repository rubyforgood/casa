# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `scout_apm` gem.
# Please instead update this file by running `bin/tapioca gem scout_apm`.

# source://yard/0.9.28/lib/yard.rb#61
::RUBY18 = T.let(T.unsafe(nil), FalseClass)

# source://yard/0.9.28/lib/yard.rb#62
::RUBY19 = T.let(T.unsafe(nil), TrueClass)

# {
# "version": 1,
# "identity": {
#   "transaction_id": "req-....",
#   "revision": "abcdef",
#   "start_instant": "01-01-01T00:00:00.0000Z",
#   "stop_instant": "01-01-01T00:00:01.0000Z",
#   "type": "Web",
#   "naming": {
#     "path": "/users",
#     "code": "UsersController#index",
#   },
#   "score": {
#     "total": 10.5,
#     "percentile": 4.5,
#     "age": 2.0,
#     "memory_delta": 3,
#     "allocations": 1
#   }
# },
#
# "tags": {
#   "allocations": 1000
# },
#
# "spans": [
#   ...
# ]
#
# source://scout_apm//lib/scout_apm/detailed_trace.rb#33
class DetailedTrace
  # @return [DetailedTrace] a new instance of DetailedTrace
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#56
  def initialize(transaction_id, revision, host, start_instant, stop_instant, type, path, code, spans, tags); end

  # Returns the value of attribute age_score.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#50
  def age_score; end

  # source://scout_apm//lib/scout_apm/detailed_trace.rb#78
  def as_json(*_arg0); end

  # Scorable interface
  #
  # Needed so we can merge ScoredItemSet instances
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#109
  def call; end

  # UsersController#show or similar
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#46
  def code; end

  # Returns the value of attribute duration.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#41
  def duration; end

  # Returns the value of attribute host.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#43
  def host; end

  # Returns the value of attribute memory_allocations_score.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#52
  def memory_allocations_score; end

  # Returns the value of attribute memory_delta_score.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#51
  def memory_delta_score; end

  # source://scout_apm//lib/scout_apm/detailed_trace.rb#113
  def name; end

  # /users/1
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#45
  def path; end

  # Returns the value of attribute percentile_score.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#49
  def percentile_score; end

  # Returns the value of attribute revision.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#38
  def revision; end

  # source://scout_apm//lib/scout_apm/detailed_trace.rb#117
  def score; end

  # Returns the value of attribute spans.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#34
  def spans; end

  # Returns the value of attribute start_instant.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#39
  def start_instant; end

  # Returns the value of attribute stop_instant.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#40
  def stop_instant; end

  # Returns the value of attribute tags.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#35
  def tags; end

  # Returns the value of attribute total_score.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#48
  def total_score; end

  # Returns the value of attribute transaction_id.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#37
  def transaction_id; end

  # "Web" or "Job"
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#42
  def type; end
end

# source://scout_apm//lib/scout_apm/detailed_trace.rb#54
DetailedTrace::VERSION = T.let(T.unsafe(nil), Integer)

# {
#   "type": "Standard",
#   "identity": {
#     "id": "....",
#     "parent_id": "....",
#     "start_time": "01-01-01T00:00:00.0000Z",
#     "stop_time": "01-01-01T00:00:00.0001Z",
#     "operation": "SQL/User/find"
#   },
#   "tags": {
#     "allocations": 1000,
#     "db.statement": "SELECT * FROM users where id = 1",
#     "db.rows": 1,
#     "backtrace": [ {
#       "file": "app/controllers/users_controller.rb",
#       "line": 10,
#       "function": "index"
#     } ]
#   }
#
# source://scout_apm//lib/scout_apm/detailed_trace.rb#147
class DetailedTraceSpan
  # @return [DetailedTraceSpan] a new instance of DetailedTraceSpan
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#162
  def initialize(span_id, parent_id, start_instant, stop_instant, operation, tags); end

  # source://scout_apm//lib/scout_apm/detailed_trace.rb#175
  def as_json(*_arg0); end

  # What is the "name" of this span.
  #
  # Examples:
  #   SQL/User/find
  #   Controller/Users/index
  #   HTTP/GET/example.com
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#160
  def operation; end

  # Returns the value of attribute parent_id.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#151
  def parent_id; end

  # Returns the value of attribute span_id.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#151
  def span_id; end

  # Returns the value of attribute span_type.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#150
  def span_type; end

  # Returns the value of attribute start_instant.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#152
  def start_instant; end

  # Returns the value of attribute stop_instant.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#152
  def stop_instant; end

  # Returns the value of attribute tags.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#148
  def tags; end
end

# Tags for either a request, or a span
#
# source://scout_apm//lib/scout_apm/detailed_trace.rb#196
class DetailedTraceTags
  # @return [DetailedTraceTags] a new instance of DetailedTraceTags
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#199
  def initialize(hash); end

  # source://scout_apm//lib/scout_apm/detailed_trace.rb#204
  def as_json(*_arg0); end

  # Returns the value of attribute tags.
  #
  # source://scout_apm//lib/scout_apm/detailed_trace.rb#197
  def tags; end
end

class Object < ::BasicObject
  include ::Kernel

  private

  # source://scout_apm//lib/scout_apm/detailed_trace.rb#210
  def DetailedTraceTags(arg); end
end

# Removes actual values from SQL. Used to both obfuscate the SQL and group
# similar queries in the UI.
#
# source://scout_apm//lib/scout_apm.rb#1
module ScoutApm; end

# The entry-point for the ScoutApm Agent.
#
# Only one Agent instance is created per-Ruby process, and it coordinates the lifecycle of the monitoring.
#   - initializes various data stores
#   - coordinates configuration & logging
#   - starts background threads, running periodically
#   - installs shutdown hooks
#
# source://scout_apm//lib/scout_apm/agent.rb#9
class ScoutApm::Agent
  # First call of the agent. Does very little so that the object can be created, and exist.
  #
  # @return [Agent] a new instance of Agent
  #
  # source://scout_apm//lib/scout_apm/agent.rb#25
  def initialize(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent.rb#197
  def background_worker_running?; end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/agent.rb#13
  def context; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent.rb#217
  def error_service_background_worker_running?; end

  # If true, the agent will start regardless of safety checks.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent.rb#123
  def force?; end

  # Finishes setting up the instrumentation, configuration, and attempts to start the agent.
  #
  # source://scout_apm//lib/scout_apm/agent.rb#35
  def install(force = T.unsafe(nil)); end

  # This sets up the background worker thread to run at the correct time,
  # either immediately, or after a fork into the actual unicorn/puma/etc
  # worker
  #
  # source://scout_apm//lib/scout_apm/agent.rb#117
  def install_app_server_integration; end

  # Attempts to install all background job integrations. This can come up if
  # an app has both Resque and Sidekiq - we want both to be installed if
  # possible, it's no harm to have the "wrong" one also installed while running.
  #
  # source://scout_apm//lib/scout_apm/agent.rb#107
  def install_background_job_integrations; end

  # Returns the value of attribute instrument_manager.
  #
  # source://scout_apm//lib/scout_apm/agent.rb#88
  def instrument_manager; end

  # source://scout_apm//lib/scout_apm/agent.rb#92
  def log_environment; end

  # source://scout_apm//lib/scout_apm/agent.rb#30
  def logger; end

  # options passed to the agent when +#start+ is called.
  #
  # source://scout_apm//lib/scout_apm/agent.rb#15
  def options; end

  # options passed to the agent when +#start+ is called.
  #
  # source://scout_apm//lib/scout_apm/agent.rb#15
  def options=(_arg0); end

  # monitor is the key configuration here. If it is true, then we want the
  # instruments. If it is false, we mostly don't want them, unless you're
  # asking for devtrace (ie. not reporting to apm servers as a real app, but
  # only for local browsers).
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent.rb#140
  def should_load_instruments?; end

  # Unconditionally starts the agent. This includes verifying instruments are
  # installed, and starting the background worker.
  #
  # The monitor precondition is checked explicitly, and we will *never* start with monitor = false
  #
  # This does not attempt to start twice
  #
  # source://scout_apm//lib/scout_apm/agent.rb#64
  def start(opts = T.unsafe(nil)); end

  # Creates the worker thread. The worker thread is a loop that runs continuously. It sleeps for +Agent#period+ and when it wakes,
  # processes data, either saving it to disk or reporting to Scout.
  # => true if thread & worker got started
  # => false if it wasn't started (either due to already running, or other preconditions)
  #
  # source://scout_apm//lib/scout_apm/agent.rb#153
  def start_background_worker(quiet = T.unsafe(nil)); end

  # The worker thread will automatically start UNLESS:
  # * A supported application server isn't detected (example: running via Rails console)
  # * A supported application server is detected, but it forks. In this case,
  #   the agent is started in the forked process.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent.rb#131
  def start_background_worker?; end

  # source://scout_apm//lib/scout_apm/agent.rb#206
  def start_error_service_background_worker; end

  # source://scout_apm//lib/scout_apm/agent.rb#185
  def stop_background_worker; end

  class << self
    # All access to the agent is thru this class method to ensure multiple Agent instances are not initialized per-Ruby process.
    #
    # source://scout_apm//lib/scout_apm/agent.rb#20
    def instance(options = T.unsafe(nil)); end
  end
end

# seconds to batch error reports
#
# source://scout_apm//lib/scout_apm/agent.rb#205
ScoutApm::Agent::ERROR_SEND_FREQUENCY = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/agent/exit_handler.rb#3
class ScoutApm::Agent::ExitHandler
  # @return [ExitHandler] a new instance of ExitHandler
  #
  # source://scout_apm//lib/scout_apm/agent/exit_handler.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/agent/exit_handler.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/agent/exit_handler.rb#10
  def install; end

  private

  # source://scout_apm//lib/scout_apm/agent/exit_handler.rb#60
  def environment; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent/exit_handler.rb#41
  def exit_handler_supported?; end

  # source://scout_apm//lib/scout_apm/agent/exit_handler.rb#56
  def logger; end

  # Called via the at_exit handler, it:
  # (1) Stops the background worker
  # (2) Stores metrics locally (forcing current-minute metrics to be written)
  # It does not attempt to actually report metrics.
  #
  # source://scout_apm//lib/scout_apm/agent/exit_handler.rb#34
  def shutdown; end
end

# source://scout_apm//lib/scout_apm/agent/preconditions.rb#3
class ScoutApm::Agent::Preconditions
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent/preconditions.rb#51
  def check?(context); end

  # XXX: Wire up options here and below in the appserver & bg server detections
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent/preconditions.rb#76
  def force?; end
end

# The preconditions here must be a 2 element hash, with :message and :check.
# message: Proc that takes the environment, and returns a string
# check: Proc that takes an AgentContext and returns true if precondition was met, if false, we shouldn't start.
# severity: Severity of the log message (one of: :debug, :info, :warn, :error or :fatal)
#
# source://scout_apm//lib/scout_apm/agent/preconditions.rb#8
ScoutApm::Agent::Preconditions::PRECONDITIONS = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/agent/preconditions.rb#38
ScoutApm::Agent::Preconditions::PRECONDITION_ALREADY_STARTED = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/agent/preconditions.rb#15
ScoutApm::Agent::Preconditions::PRECONDITION_APP_NAME = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/agent/preconditions.rb#27
ScoutApm::Agent::Preconditions::PRECONDITION_DETECTED_SERVER = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/agent/preconditions.rb#9
ScoutApm::Agent::Preconditions::PRECONDITION_ENABLED = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/agent/preconditions.rb#21
ScoutApm::Agent::Preconditions::PRECONDITION_INTERACTIVE = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/agent/preconditions.rb#44
ScoutApm::Agent::Preconditions::PRECONDITION_OLD_SCOUT_RAILS = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/agent_context.rb#2
class ScoutApm::AgentContext
  # Initially start up without attempting to load a configuration file. We
  # need to be able to lookup configuration options like "application_root"
  # which would then in turn influence where the yaml configuration file is
  # located
  #
  # Later in initialization, we set config= to include the file.
  #
  # @return [AgentContext] a new instance of AgentContext
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#12
  def initialize; end

  # Maintains a Histogram of insignificant/significant autoinstrument layers.
  # significant = 1
  # insignificant = 0
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#109
  def auto_instruments_layer_histograms; end

  # Execute this in the child process of a remote agent. The parent is
  # expected to have its accepting webserver up and running
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#57
  def become_remote_client!(host, port); end

  # source://scout_apm//lib/scout_apm/agent_context.rb#70
  def config; end

  # When we set the config for any reason, there are some values we must
  # reinitialize, since the config could have changed their settings, so nil
  # them out here, then let them get lazily reset as needed
  #
  # Don't use this in initializer, since it'll attempt to log immediately
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#166
  def config=(config); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#141
  def dev_trace_enabled?; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#74
  def environment; end

  # I believe this is only useful for testing?
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#210
  def environment=(env); end

  # Error Service  #
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#149
  def error_buffer; end

  # Returns the value of attribute extensions.
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#4
  def extensions; end

  # Sets the attribute extensions
  #
  # @param value the value to set the attribute extensions to.
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#4
  def extensions=(_arg0); end

  # source://scout_apm//lib/scout_apm/agent_context.rb#153
  def ignored_exceptions; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#94
  def ignored_uris; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#183
  def installed!; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#86
  def installed?; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#133
  def layaway; end

  # Called after config is reset and loaded from file
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#221
  def log_configuration_settings; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#90
  def logger; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#18
  def marshal_dump; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#22
  def marshal_load(*args); end

  # Accessors  #
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#68
  def process_start_time; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#137
  def recorder; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#205
  def recorder=(recorder); end

  # Histogram of the cumulative requests since the start of the process
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#114
  def request_histograms; end

  # Histogram of the requests, distinct by reporting period (minute)
  # { StoreReportingPeriodTimestamp => RequestHistograms }
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#120
  def request_histograms_by_time; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#191
  def shutting_down!; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#82
  def shutting_down?; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#102
  def slow_job_policy; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#98
  def slow_request_policy; end

  # Lifecycle: Remote Server/Client
  #
  #  This allows short lived forked processes to communicate back to the parent process.
  #  Used in the Resque instrumentation
  #
  #  Parent Pre-fork: start_remote_server! once
  #  Child Post-fork: become_remote_client! after each fork
  #
  #  TODO: Figure out where to extract this to
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#39
  def start_remote_server!(bind, port); end

  # source://scout_apm//lib/scout_apm/agent_context.rb#187
  def started!; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/agent_context.rb#78
  def started?; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#128
  def store; end

  # source://scout_apm//lib/scout_apm/agent_context.rb#195
  def store=(store); end

  # source://scout_apm//lib/scout_apm/agent_context.rb#124
  def transaction_time_consumed; end
end

# source://scout_apm//lib/scout_apm/exceptions.rb#2
module ScoutApm::AllExceptionsExceptOnesWeMustNotRescue
  class << self
    # source://scout_apm//lib/scout_apm/exceptions.rb#8
    def ===(exception); end
  end
end

# Borrowed from https://github.com/rspec/rspec-support/blob/v3.8.0/lib/rspec/support.rb#L132-L140
# These exceptions are dangerous to rescue as rescuing them
# would interfere with things we should not interfere with.
#
# source://scout_apm//lib/scout_apm/exceptions.rb#6
ScoutApm::AllExceptionsExceptOnesWeMustNotRescue::AVOID_RESCUING = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/app_server_load.rb#2
class ScoutApm::AppServerLoad
  # @return [AppServerLoad] a new instance of AppServerLoad
  #
  # source://scout_apm//lib/scout_apm/app_server_load.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/app_server_load.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/app_server_load.rb#31
  def data; end

  # source://scout_apm//lib/scout_apm/app_server_load.rb#67
  def environment; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/app_server_load.rb#3
  def logger; end

  # source://scout_apm//lib/scout_apm/app_server_load.rb#11
  def run; end

  # Calls `.to_s` on the object passed in.
  # Returns literal string 'to_s error' if the object does not respond to .to_s
  #
  # source://scout_apm//lib/scout_apm/app_server_load.rb#59
  def to_s_safe(obj); end
end

# source://scout_apm//lib/scout_apm/attribute_arranger.rb#2
module ScoutApm::AttributeArranger
  class << self
    # pass in an array of symbols to return as hash keys
    # if the symbol doesn't match the name of the method, pass an array: [:key, :method_name]
    #
    # source://scout_apm//lib/scout_apm/attribute_arranger.rb#5
    def call(subject, attributes_list); end
  end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#2
module ScoutApm::BackgroundJobIntegrations; end

# source://scout_apm//lib/scout_apm/background_job_integrations/delayed_job.rb#3
class ScoutApm::BackgroundJobIntegrations::DelayedJob
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/delayed_job.rb#17
  def forking?; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/delayed_job.rb#21
  def install; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/delayed_job.rb#7
  def logger; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/delayed_job.rb#9
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/delayed_job.rb#13
  def present?; end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/delayed_job.rb#4
ScoutApm::BackgroundJobIntegrations::DelayedJob::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/delayed_job.rb#5
ScoutApm::BackgroundJobIntegrations::DelayedJob::DJ_PERFORMABLE_METHOD = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#3
class ScoutApm::BackgroundJobIntegrations::Faktory
  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#23
  def add_middleware; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#14
  def forking?; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#18
  def install; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#31
  def install_processor; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#6
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#10
  def present?; end
end

# We insert this middleware into the Sidekiq stack, to capture each job,
# and time them.
#
# source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#49
class ScoutApm::BackgroundJobIntegrations::FaktoryMiddleware
  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#50
  def call(worker_instance, job); end

  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#75
  def job_class(job); end

  # source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#91
  def latency(job, time = T.unsafe(nil)); end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#73
ScoutApm::BackgroundJobIntegrations::FaktoryMiddleware::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/faktory.rb#72
ScoutApm::BackgroundJobIntegrations::FaktoryMiddleware::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/legacy_sneakers.rb#13
module ScoutApm::BackgroundJobIntegrations::LegacySneakers
  # source://scout_apm//lib/scout_apm/background_job_integrations/legacy_sneakers.rb#20
  def initialize(*args); end

  # source://scout_apm//lib/scout_apm/background_job_integrations/legacy_sneakers.rb#29
  def work_with_params(msg, delivery_info, metadata); end

  class << self
    # source://scout_apm//lib/scout_apm/background_job_integrations/legacy_sneakers.rb#16
    def prepended(base); end
  end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/legacy_sneakers.rb#14
ScoutApm::BackgroundJobIntegrations::LegacySneakers::UNKNOWN_QUEUE_PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#3
class ScoutApm::BackgroundJobIntegrations::Que
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#23
  def forking?; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#27
  def install; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#52
  def install_job; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#33
  def install_tracer; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#39
  def install_worker; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#9
  def logger; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#11
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#15
  def present?; end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#6
ScoutApm::BackgroundJobIntegrations::Que::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#5
ScoutApm::BackgroundJobIntegrations::Que::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/que.rb#7
ScoutApm::BackgroundJobIntegrations::Que::UNKNOWN_QUEUE_PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#3
class ScoutApm::BackgroundJobIntegrations::Resque
  # Lies. This forks really aggressively, but we have to do handling
  # of it manually here, rather than via any sort of automatic
  # background worker starting
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#17
  def forking?; end

  # Insert ourselves into the point when resque turns a string "TestJob"
  # into the class constant TestJob, and insert our instrumentation plugin
  # into that constantized class
  #
  # This automates away any need for the user to insert our instrumentation into
  # each of their jobs
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#60
  def inject_job_instrument; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#21
  def install; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#43
  def install_after_fork; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#26
  def install_before_fork; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#4
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#8
  def present?; end

  private

  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#74
  def bind; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#82
  def config; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/resque.rb#78
  def port; end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#3
class ScoutApm::BackgroundJobIntegrations::Shoryuken
  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#31
  def add_middleware; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#14
  def forking?; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#18
  def install; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#39
  def install_processor; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#24
  def install_tracer; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#6
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#10
  def present?; end
end

# We insert this middleware into the Shoryuken stack, to capture each job,
# and time them.
#
# source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#59
class ScoutApm::BackgroundJobIntegrations::ShoryukenMiddleware
  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#60
  def call(worker_instance, queue, msg, body); end

  # source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#94
  def latency(msg, time = T.unsafe(nil)); end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#92
ScoutApm::BackgroundJobIntegrations::ShoryukenMiddleware::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/shoryuken.rb#91
ScoutApm::BackgroundJobIntegrations::ShoryukenMiddleware::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#3
class ScoutApm::BackgroundJobIntegrations::Sidekiq
  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#31
  def add_middleware; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#14
  def forking?; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#18
  def install; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#39
  def install_processor; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#24
  def install_tracer; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#6
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#10
  def present?; end
end

# We insert this middleware into the Sidekiq stack, to capture each job,
# and time them.
#
# source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#51
class ScoutApm::BackgroundJobIntegrations::SidekiqMiddleware
  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#52
  def call(_worker, msg, queue); end

  # Capturing the class name is a little tricky, since we need to handle several cases:
  # 1. ActiveJob, with the class in the key 'wrapped'
  # 2. ActiveJob, but the 'wrapped' key is wrong (due to YAJL serializing weirdly), find it in args.job_class
  # 3. DelayedJob wrapper, deserializing using YAML into the real object, which can be introspected
  # 4. No wrapper, just sidekiq's class
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#82
  def job_class(msg); end

  # source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#119
  def latency(msg, time = T.unsafe(nil)); end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#73
ScoutApm::BackgroundJobIntegrations::SidekiqMiddleware::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#74
ScoutApm::BackgroundJobIntegrations::SidekiqMiddleware::DELAYED_WRAPPER_KLASS = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/sidekiq.rb#72
ScoutApm::BackgroundJobIntegrations::SidekiqMiddleware::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#3
class ScoutApm::BackgroundJobIntegrations::Sneakers
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#22
  def forking?; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#26
  def install; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#30
  def install_worker_override; end

  # source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#4
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#8
  def present?; end

  # Only support Sneakers 2.7 and up
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#13
  def supported_version?; end
end

# source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#82
ScoutApm::BackgroundJobIntegrations::Sneakers::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#83
ScoutApm::BackgroundJobIntegrations::Sneakers::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_job_integrations/sneakers.rb#84
ScoutApm::BackgroundJobIntegrations::Sneakers::UNKNOWN_QUEUE_PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/background_recorder.rb#6
class ScoutApm::BackgroundRecorder
  # @return [BackgroundRecorder] a new instance of BackgroundRecorder
  #
  # source://scout_apm//lib/scout_apm/background_recorder.rb#12
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/background_recorder.rb#7
  def context; end

  # source://scout_apm//lib/scout_apm/background_recorder.rb#17
  def logger; end

  # Returns the value of attribute queue.
  #
  # source://scout_apm//lib/scout_apm/background_recorder.rb#9
  def queue; end

  # source://scout_apm//lib/scout_apm/background_recorder.rb#31
  def record!(request); end

  # source://scout_apm//lib/scout_apm/background_recorder.rb#21
  def start; end

  # source://scout_apm//lib/scout_apm/background_recorder.rb#27
  def stop; end

  # Returns the value of attribute thread.
  #
  # source://scout_apm//lib/scout_apm/background_recorder.rb#10
  def thread; end

  # source://scout_apm//lib/scout_apm/background_recorder.rb#36
  def thread_func; end
end

# source://scout_apm//lib/scout_apm/background_worker.rb#3
class ScoutApm::BackgroundWorker
  # @return [BackgroundWorker] a new instance of BackgroundWorker
  #
  # source://scout_apm//lib/scout_apm/background_worker.rb#11
  def initialize(context, period = T.unsafe(nil)); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/background_worker.rb#9
  def context; end

  # source://scout_apm//lib/scout_apm/background_worker.rb#17
  def logger; end

  # Returns the value of attribute period.
  #
  # source://scout_apm//lib/scout_apm/background_worker.rb#7
  def period; end

  # Runs the task passed to +start+ once.
  #
  # source://scout_apm//lib/scout_apm/background_worker.rb#31
  def run_once; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/background_worker.rb#21
  def running?; end

  # Starts running the passed block every 60 seconds (starting now).
  #
  # source://scout_apm//lib/scout_apm/background_worker.rb#36
  def start(&block); end

  # source://scout_apm//lib/scout_apm/background_worker.rb#25
  def stop; end
end

# in seconds, time between when the worker thread wakes up and runs.
#
# source://scout_apm//lib/scout_apm/background_worker.rb#5
ScoutApm::BackgroundWorker::DEFAULT_PERIOD = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/bucket_name_splitter.rb#2
module ScoutApm::BucketNameSplitter
  # source://scout_apm//lib/scout_apm/bucket_name_splitter.rb#7
  def bucket_name; end

  # source://scout_apm//lib/scout_apm/bucket_name_splitter.rb#3
  def bucket_type; end

  # source://scout_apm//lib/scout_apm/bucket_name_splitter.rb#11
  def key; end

  private

  # source://scout_apm//lib/scout_apm/bucket_name_splitter.rb#20
  def scope_hash; end

  # source://scout_apm//lib/scout_apm/bucket_name_splitter.rb#16
  def split_metric_name(metric_name); end
end

# Encapsulates our logic to determine when a backtrace should be collected.
#
# source://scout_apm//lib/scout_apm/call_set.rb#3
class ScoutApm::CallSet
  # @return [CallSet] a new instance of CallSet
  #
  # source://scout_apm//lib/scout_apm/call_set.rb#10
  def initialize; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/call_set.rb#45
  def at_magic_number?; end

  # Returns the value of attribute call_count.
  #
  # source://scout_apm//lib/scout_apm/call_set.rb#8
  def call_count; end

  # We're selective on capturing a backtrace for two reasons:
  # * Grouping ActiveRecord calls requires us to sanitize the SQL. This isn't cheap.
  # * Capturing backtraces isn't cheap.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/call_set.rb#39
  def capture_backtrace?; end

  # source://scout_apm//lib/scout_apm/call_set.rb#49
  def grouped_items; end

  # Limit our workload if time across this set of calls is small.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/call_set.rb#31
  def past_time_threshold?; end

  # Determine this items' "hash key"
  #
  # source://scout_apm//lib/scout_apm/call_set.rb#58
  def unique_name_for(item); end

  # source://scout_apm//lib/scout_apm/call_set.rb#19
  def update!(item = T.unsafe(nil)); end
end

# Fetch backtraces on this number of calls to a layer. The caller data is only collected on this call to limit overhead.
#
# source://scout_apm//lib/scout_apm/call_set.rb#5
ScoutApm::CallSet::N_PLUS_ONE_MAGIC_NUMBER = T.let(T.unsafe(nil), Integer)

# Minimum time in seconds before we start performing any work. This is to prevent doing a lot of work on already fast calls.
#
# source://scout_apm//lib/scout_apm/call_set.rb#6
ScoutApm::CallSet::N_PLUS_ONE_TIME_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://scout_apm//lib/scout_apm/config.rb#50
class ScoutApm::Config
  # @return [Config] a new instance of Config
  #
  # source://scout_apm//lib/scout_apm/config.rb#238
  def initialize(context, overlays); end

  # Returns an array of config keys, values, and source
  # {key: "monitor", value: "true", source: "environment"}
  #
  # source://scout_apm//lib/scout_apm/config.rb#273
  def all_settings; end

  # Did we load anything for configuration?
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#266
  def any_keys_found?; end

  # source://scout_apm//lib/scout_apm/config.rb#280
  def log_settings(logger); end

  # source://scout_apm//lib/scout_apm/config.rb#287
  def logger; end

  # For a given key, what is the first overlay says that it can handle it?
  #
  # source://scout_apm//lib/scout_apm/config.rb#244
  def overlay_for_key(key); end

  # source://scout_apm//lib/scout_apm/config.rb#248
  def value(key); end

  class << self
    # Load up a config instance, attempting to load a yaml file.  Allows a
    # definite location if requested, or will attempt to load the default
    # configuration file: APP_ROOT/config/scout_apm.yml
    #
    # source://scout_apm//lib/scout_apm/config.rb#228
    def with_file(context, file_path = T.unsafe(nil), config = T.unsafe(nil)); end

    # Load up a config instance without attempting to load a file.
    # Useful for bootstrapping.
    #
    # source://scout_apm//lib/scout_apm/config.rb#216
    def without_file(context); end
  end
end

# Any boolean is passed through
# A string is false iff it is 0 length, is "f", or "false" - otherwise true
# An number is false if it is exactly 0
# Other types are false
#
# source://scout_apm//lib/scout_apm/config.rb#122
class ScoutApm::Config::BooleanCoercion
  # source://scout_apm//lib/scout_apm/config.rb#123
  def coerce(val); end

  # source://scout_apm//lib/scout_apm/config.rb#140
  def coerce_string(val); end
end

# source://scout_apm//lib/scout_apm/config.rb#291
class ScoutApm::Config::ConfigDefaults
  # Defaults are here, but not counted as user specified.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#339
  def any_keys_found?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#334
  def has_key?(key); end

  # source://scout_apm//lib/scout_apm/config.rb#343
  def name; end

  # source://scout_apm//lib/scout_apm/config.rb#330
  def value(key); end
end

# source://scout_apm//lib/scout_apm/config.rb#292
ScoutApm::Config::ConfigDefaults::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/config.rb#370
class ScoutApm::Config::ConfigEnvironment
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#384
  def any_keys_found?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#376
  def has_key?(key); end

  # source://scout_apm//lib/scout_apm/config.rb#380
  def key_to_env_key(key); end

  # source://scout_apm//lib/scout_apm/config.rb#390
  def name; end

  # source://scout_apm//lib/scout_apm/config.rb#371
  def value(key); end
end

# Attempts to load a configuration file, and parse it as YAML. If the file
# is not found, inaccessbile, or unparsable, log a message to that effect,
# and move on.
#
# source://scout_apm//lib/scout_apm/config.rb#398
class ScoutApm::Config::ConfigFile
  # @return [ConfigFile] a new instance of ConfigFile
  #
  # source://scout_apm//lib/scout_apm/config.rb#399
  def initialize(context, file_path = T.unsafe(nil), config = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#419
  def any_keys_found?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#415
  def has_key?(key); end

  # source://scout_apm//lib/scout_apm/config.rb#425
  def name; end

  # source://scout_apm//lib/scout_apm/config.rb#406
  def value(key); end

  private

  # source://scout_apm//lib/scout_apm/config.rb#471
  def app_environment; end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/config.rb#431
  def context; end

  # source://scout_apm//lib/scout_apm/config.rb#467
  def determine_file_path; end

  # source://scout_apm//lib/scout_apm/config.rb#433
  def load_file(file); end

  # source://scout_apm//lib/scout_apm/config.rb#475
  def logger; end
end

# Good News: It has every config value you could want
# Bad News: The content of that config value is always nil
# Used for the null-object pattern
#
# source://scout_apm//lib/scout_apm/config.rb#352
class ScoutApm::Config::ConfigNull
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#361
  def any_keys_found?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/config.rb#357
  def has_key?(*_arg0); end

  # source://scout_apm//lib/scout_apm/config.rb#365
  def name; end

  # source://scout_apm//lib/scout_apm/config.rb#353
  def value(*_arg0); end
end

# source://scout_apm//lib/scout_apm/config.rb#167
class ScoutApm::Config::IntegerCoercion
  # source://scout_apm//lib/scout_apm/config.rb#168
  def coerce(val); end
end

# If the passed value is a string, attempt to decode as json
# This is a no-op unless the `JSON` constant is defined
#
# source://scout_apm//lib/scout_apm/config.rb#152
class ScoutApm::Config::JsonCoercion
  # source://scout_apm//lib/scout_apm/config.rb#153
  def coerce(val); end
end

# source://scout_apm//lib/scout_apm/config.rb#51
ScoutApm::Config::KNOWN_CONFIG_OPTIONS = T.let(T.unsafe(nil), Array)

# Simply returns the passed in value, without change
#
# source://scout_apm//lib/scout_apm/config.rb#174
class ScoutApm::Config::NullCoercion
  # source://scout_apm//lib/scout_apm/config.rb#175
  def coerce(val); end
end

# source://scout_apm//lib/scout_apm/config.rb#181
ScoutApm::Config::SETTING_COERCIONS = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/context.rb#7
class ScoutApm::Context
  # @return [Context] a new instance of Context
  #
  # source://scout_apm//lib/scout_apm/context.rb#10
  def initialize(context); end

  # Add context
  # ScoutApm::Context.add(account: current_account.name)
  #
  # source://scout_apm//lib/scout_apm/context.rb#41
  def add(hash); end

  # source://scout_apm//lib/scout_apm/context.rb#45
  def add_user(hash); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/context.rb#8
  def context; end

  # source://scout_apm//lib/scout_apm/context.rb#16
  def logger; end

  # source://scout_apm//lib/scout_apm/context.rb#26
  def to_flat_hash; end

  # Generates a hash representation of the Context.
  # Example: {:monthly_spend => 100, :user => {:ip => '127.0.0.1'}}
  #
  # source://scout_apm//lib/scout_apm/context.rb#22
  def to_hash; end

  private

  # for consistently with #value_valid?, takes a hash eventhough the value isn't yet used.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/context.rb#105
  def key_valid?(key_value); end

  # source://scout_apm//lib/scout_apm/context.rb#61
  def update_context(attr, hash); end

  # Returns true if the obj is one of the provided valid classes.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/context.rb#79
  def valid_type?(classes, obj); end

  # take the entire Hash vs. just the value so the logger output is more helpful on error.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/context.rb#91
  def value_valid?(key_value); end

  class << self
    # Convenience accessor so you can just call @ScoutAPM::Context#add@
    #
    # source://scout_apm//lib/scout_apm/context.rb#50
    def add(hash); end

    # Convenience accessor so you can just call @ScoutAPM::Context#add_user@
    #
    # source://scout_apm//lib/scout_apm/context.rb#55
    def add_user(hash); end

    # source://scout_apm//lib/scout_apm/context.rb#35
    def current; end
  end
end

# source://scout_apm//lib/scout_apm/db_query_metric_set.rb#3
class ScoutApm::DbQueryMetricSet
  include ::Enumerable

  # @return [DbQueryMetricSet] a new instance of DbQueryMetricSet
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#17
  def initialize(context); end

  # Add a single DbQueryMetricStats object to this set.
  #
  # Looks up an existing one under this key and merges, or just saves a new
  # one under the key
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#54
  def <<(stat); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#91
  def at_limit?; end

  # Take another set, and merge it with this one
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#43
  def combine!(other); end

  # Need to look this up again if we end up as nil. Which I guess can happen
  # after a Marshal load?
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#26
  def context; end

  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#30
  def each; end

  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#66
  def increment_transaction_count!; end

  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#85
  def inspect; end

  # Looks up a DbQueryMetricStats instance in the +@metrics+ hash. Sets the value to +other+ if no key
  # Returns a DbQueryMetricStats instance
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#38
  def lookup(other); end

  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#8
  def marshal_dump; end

  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#12
  def marshal_load(array); end

  # the raw metrics. You probably want #metrics_to_report
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#6
  def metrics; end

  # source://scout_apm//lib/scout_apm/db_query_metric_set.rb#72
  def metrics_to_report; end
end

# source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#2
class ScoutApm::DbQueryMetricStats
  # @return [DbQueryMetricStats] a new instance of DbQueryMetricStats
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#24
  def initialize(model_name, operation, scope, call_count, call_time, rows_returned); end

  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#72
  def as_json; end

  # Returns the value of attribute call_count.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#12
  def call_count; end

  # Returns the value of attribute call_time.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#13
  def call_time; end

  # Combine data from another DbQueryMetricStats into +self+. Modifies and returns +self+
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#54
  def combine!(other); end

  # Returns the value of attribute histogram.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#22
  def histogram; end

  # Called by the Set on each DbQueryMetricStats object that it holds, only
  # once during the recording of a transaction.
  #
  # Don't call elsewhere, and don't set to 1 in the initializer.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#98
  def increment_transaction_count!; end

  # Merge data in this scope. Used in DbQueryMetricSet
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#49
  def key; end

  # Returns the value of attribute max_call_time.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#17
  def max_call_time; end

  # Returns the value of attribute max_rows_returned.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#20
  def max_rows_returned; end

  # Returns the value of attribute min_call_time.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#16
  def min_call_time; end

  # Returns the value of attribute min_rows_returned.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#19
  def min_rows_returned; end

  # Returns the value of attribute model_name.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#6
  def model_name; end

  # Returns the value of attribute operation.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#7
  def operation; end

  # Returns the value of attribute rows_returned.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#14
  def rows_returned; end

  # Returns the value of attribute scope.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#8
  def scope; end

  # Returns the value of attribute transaction_count.
  #
  # source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#10
  def transaction_count; end
end

# source://scout_apm//lib/scout_apm/db_query_metric_stats.rb#4
ScoutApm::DbQueryMetricStats::DEFAULT_HISTOGRAM_SIZE = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/debug.rb#2
class ScoutApm::Debug
  # @return [Debug] a new instance of Debug
  #
  # source://scout_apm//lib/scout_apm/debug.rb#29
  def initialize; end

  # source://scout_apm//lib/scout_apm/debug.rb#14
  def call_periodic_hooks; end

  # source://scout_apm//lib/scout_apm/debug.rb#10
  def register_periodic_hook(&hook); end

  private

  # source://scout_apm//lib/scout_apm/debug.rb#33
  def logger; end

  class << self
    # source://scout_apm//lib/scout_apm/debug.rb#6
    def instance; end
  end
end

# source://scout_apm//lib/scout_apm/environment.rb#5
class ScoutApm::Environment
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # App server's name (symbol)
  #
  # source://scout_apm//lib/scout_apm/environment.rb#138
  def app_server; end

  # Returns the whole integration object
  # This needs to be improved. Frequently, multiple app servers gem are present and which
  # ever is checked first becomes the designated app server.
  #
  # Next step: (1) list out all detected app servers (2) install hooks for those that need it (passenger, rainbows, unicorn).
  #
  # source://scout_apm//lib/scout_apm/environment.rb#132
  def app_server_integration(force = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/environment.rb#65
  def application_name; end

  # source://scout_apm//lib/scout_apm/environment.rb#148
  def background_job_integrations; end

  # source://scout_apm//lib/scout_apm/environment.rb#71
  def database_engine; end

  # source://scout_apm//lib/scout_apm/environment.rb#49
  def env; end

  # If forking, don't start worker thread in the master process. Since it's
  # started as a Thread, it won't survive the fork.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#144
  def forking?; end

  # source://scout_apm//lib/scout_apm/environment.rb#53
  def framework; end

  # source://scout_apm//lib/scout_apm/environment.rb#57
  def framework_integration; end

  # source://scout_apm//lib/scout_apm/environment.rb#104
  def framework_root; end

  # source://scout_apm//lib/scout_apm/environment.rb#123
  def git_revision; end

  # source://scout_apm//lib/scout_apm/environment.rb#119
  def hostname; end

  # If both stdin & stdout are interactive and the Rails::Console constant is defined
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#157
  def interactive?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#167
  def jruby?; end

  # Returns a string representation of the OS (ex: darwin, linux)
  #
  # source://scout_apm//lib/scout_apm/environment.rb#207
  def os; end

  # source://scout_apm//lib/scout_apm/environment.rb#61
  def platform_integration; end

  # source://scout_apm//lib/scout_apm/environment.rb#79
  def processors; end

  # source://scout_apm//lib/scout_apm/environment.rb#75
  def raw_database_adapter; end

  # source://scout_apm//lib/scout_apm/environment.rb#100
  def root; end

  # ruby checks
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#163
  def rubinius?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#176
  def ruby_187?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#171
  def ruby_19?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#181
  def ruby_2?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#186
  def ruby_3?; end

  # source://scout_apm//lib/scout_apm/environment.rb#191
  def ruby_minor; end

  # source://scout_apm//lib/scout_apm/environment.rb#92
  def scm_subdirectory; end

  # framework checks
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#220
  def sinatra?; end

  # Returns true if this Ruby version makes positional and keyword arguments incompatible
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#202
  def supports_kwarg_delegation?; end

  # Returns true if this Ruby version supports Module#prepend.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/environment.rb#197
  def supports_module_prepend?; end
end

# source://scout_apm//lib/scout_apm/environment.rb#26
ScoutApm::Environment::BACKGROUND_JOB_INTEGRATIONS = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/environment.rb#36
ScoutApm::Environment::FRAMEWORK_INTEGRATIONS = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/environment.rb#43
ScoutApm::Environment::PLATFORM_INTEGRATIONS = T.let(T.unsafe(nil), Array)

# I've put Thin and Webrick last as they are often used in development and included in Gemfiles
# but less likely used in production.
#
# source://scout_apm//lib/scout_apm/environment.rb#16
ScoutApm::Environment::SERVER_INTEGRATIONS = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/environment.rb#8
ScoutApm::Environment::STDOUT_LOGGER = T.let(T.unsafe(nil), Logger)

# source://scout_apm//lib/scout_apm/error.rb#5
module ScoutApm::Error
  class << self
    # Capture an exception, optionally with an environment hash. This may be a
    # Rack environment, but is not required.
    #
    # source://scout_apm//lib/scout_apm/error.rb#8
    def capture(exception, env = T.unsafe(nil)); end
  end
end

# source://scout_apm//lib/scout_apm/error_service.rb#6
module ScoutApm::ErrorService
  class << self
    # Public API to force a given exception to be captured.
    # Still obeys the ignore list
    # Used internally by SidekiqException
    #
    # source://scout_apm//lib/scout_apm/error_service.rb#17
    def capture(exception, params = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://scout_apm//lib/scout_apm/error_service.rb#30
    def disabled?; end

    # @return [Boolean]
    #
    # source://scout_apm//lib/scout_apm/error_service.rb#26
    def enabled?; end
  end
end

# source://scout_apm//lib/scout_apm/error_service.rb#7
ScoutApm::ErrorService::API_VERSION = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/error_service/error_buffer.rb#4
class ScoutApm::ErrorService::ErrorBuffer
  include ::Enumerable

  # @return [ErrorBuffer] a new instance of ErrorBuffer
  #
  # source://scout_apm//lib/scout_apm/error_service/error_buffer.rb#9
  def initialize(agent_context); end

  # Returns the value of attribute agent_context.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_buffer.rb#7
  def agent_context; end

  # source://scout_apm//lib/scout_apm/error_service/error_buffer.rb#15
  def capture(exception, env); end

  # Enables enumerable - for count and each and similar methods
  #
  # source://scout_apm//lib/scout_apm/error_service/error_buffer.rb#32
  def each; end

  # source://scout_apm//lib/scout_apm/error_service/error_buffer.rb#23
  def get_and_reset_error_records; end
end

# Converts the raw error data captured into the captured data, and holds it
# until it's ready to be reported.
#
# source://scout_apm//lib/scout_apm/error_service/error_record.rb#5
class ScoutApm::ErrorService::ErrorRecord
  # @return [ErrorRecord] a new instance of ErrorRecord
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#16
  def initialize(agent_context, exception, env, context = T.unsafe(nil)); end

  # TODO: When was backtrace_cleaner introduced?
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#83
  def clean_backtrace(backtrace); end

  # TODO: This name is too vague
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#75
  def clean_params(params); end

  # TODO: This is rails specific
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#36
  def components(env); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#14
  def context; end

  # Returns the value of attribute environment.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#11
  def environment; end

  # Returns the value of attribute exception_class.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#6
  def exception_class; end

  # Check, if a key should be filtered
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#173
  def filter_key?(key); end

  # Replaces parameter values with a string / set in config file
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#158
  def filter_params(params); end

  # Accessor for the filtered params config value. Will be removed as we refactor and clean up this code.
  # TODO: Flip this over to use a new class like filtered exceptions?
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#185
  def filtered_params_config; end

  # Returns the value of attribute message.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#7
  def message; end

  # TODO: Rename and make this clearer. I think it maps over the whole tree of a hash, and to_s each leaf node?
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#135
  def normalize_data(hash); end

  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#179
  def params_to_filter; end

  # TODO: Can I use the same thing we use in traces?
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#52
  def rack_request_url(env); end

  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#64
  def rack_scheme(env); end

  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#189
  def rails_filtered_params; end

  # Returns the value of attribute request_components.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#13
  def request_components; end

  # Returns the value of attribute request_params.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#9
  def request_params; end

  # Returns the value of attribute request_session.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#10
  def request_session; end

  # Returns the value of attribute request_uri.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#8
  def request_uri; end

  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#123
  def session_data(env); end

  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#119
  def strip_env(env); end

  # Returns the value of attribute trace.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#12
  def trace; end
end

# Deletes params from env
#
# These are not configurable, and will leak PII info up to Scout if
# allowed through. Things like specific parameters can be exposed with
# the ScoutApm::Context interface.
#
# source://scout_apm//lib/scout_apm/error_service/error_record.rb#96
ScoutApm::ErrorService::ErrorRecord::KEYS_TO_REMOVE = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/error_service/error_record.rb#196
class ScoutApm::ErrorService::ErrorRecord::LengthLimit
  # @return [LengthLimit] a new instance of LengthLimit
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#200
  def initialize(text, char_limit = T.unsafe(nil)); end

  # Returns the value of attribute char_limit.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#198
  def char_limit; end

  # Returns the value of attribute text.
  #
  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#197
  def text; end

  # source://scout_apm//lib/scout_apm/error_service/error_record.rb#205
  def to_s; end
end

# source://scout_apm//lib/scout_apm/error_service.rb#9
ScoutApm::ErrorService::HEADERS = T.let(T.unsafe(nil), Hash)

# source://scout_apm//lib/scout_apm/error_service/ignored_exceptions.rb#5
class ScoutApm::ErrorService::IgnoredExceptions
  # @return [IgnoredExceptions] a new instance of IgnoredExceptions
  #
  # source://scout_apm//lib/scout_apm/error_service/ignored_exceptions.rb#9
  def initialize(context, from_config); end

  # Add a single ignored exception by class name
  #
  # source://scout_apm//lib/scout_apm/error_service/ignored_exceptions.rb#16
  def add(klass_or_str); end

  # Add a callback block that will be called on every error. If it returns
  # Signature of blocks:  ->(exception object): truthy or falsy value
  #
  # source://scout_apm//lib/scout_apm/error_service/ignored_exceptions.rb#22
  def add_callback(&block); end

  # Returns the value of attribute blocks.
  #
  # source://scout_apm//lib/scout_apm/error_service/ignored_exceptions.rb#7
  def blocks; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/error_service/ignored_exceptions.rb#26
  def ignored?(exception_object); end

  # Returns the value of attribute ignored_exceptions.
  #
  # source://scout_apm//lib/scout_apm/error_service/ignored_exceptions.rb#6
  def ignored_exceptions; end

  private

  # source://scout_apm//lib/scout_apm/error_service/ignored_exceptions.rb#46
  def normalize_as_klass(klass_or_str); end
end

# source://scout_apm//lib/scout_apm/error_service/middleware.rb#3
class ScoutApm::ErrorService::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://scout_apm//lib/scout_apm/error_service/middleware.rb#4
  def initialize(app); end

  # source://scout_apm//lib/scout_apm/error_service/middleware.rb#8
  def call(env); end
end

# source://scout_apm//lib/scout_apm/error_service/notifier.rb#3
class ScoutApm::ErrorService::Notifier
  # @return [Notifier] a new instance of Notifier
  #
  # source://scout_apm//lib/scout_apm/error_service/notifier.rb#7
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/error_service/notifier.rb#4
  def context; end

  # Returns the value of attribute reporter.
  #
  # source://scout_apm//lib/scout_apm/error_service/notifier.rb#5
  def reporter; end

  # source://scout_apm//lib/scout_apm/error_service/notifier.rb#12
  def ship; end

  private

  # source://scout_apm//lib/scout_apm/error_service/notifier.rb#25
  def default_headers; end
end

# source://scout_apm//lib/scout_apm/error_service/payload.rb#3
class ScoutApm::ErrorService::Payload
  # @return [Payload] a new instance of Payload
  #
  # source://scout_apm//lib/scout_apm/error_service/payload.rb#7
  def initialize(context, errors); end

  # source://scout_apm//lib/scout_apm/error_service/payload.rb#19
  def as_json; end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/error_service/payload.rb#4
  def context; end

  # Returns the value of attribute errors.
  #
  # source://scout_apm//lib/scout_apm/error_service/payload.rb#5
  def errors; end

  # TODO: Don't use to_json since it isn't supported in Ruby 1.8.7
  #
  # source://scout_apm//lib/scout_apm/error_service/payload.rb#13
  def serialize; end

  # source://scout_apm//lib/scout_apm/error_service/payload.rb#32
  def serialize_error_record(error_record); end
end

# source://scout_apm//lib/scout_apm/error_service/periodic_work.rb#3
class ScoutApm::ErrorService::PeriodicWork
  # @return [PeriodicWork] a new instance of PeriodicWork
  #
  # source://scout_apm//lib/scout_apm/error_service/periodic_work.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/error_service/periodic_work.rb#4
  def context; end

  # Expected to be called many times over the life of the agent
  #
  # source://scout_apm//lib/scout_apm/error_service/periodic_work.rb#12
  def run; end
end

# source://scout_apm//lib/scout_apm/error_service/sidekiq.rb#3
class ScoutApm::ErrorService::Sidekiq
  # @return [Sidekiq] a new instance of Sidekiq
  #
  # source://scout_apm//lib/scout_apm/error_service/sidekiq.rb#4
  def initialize; end

  # source://scout_apm//lib/scout_apm/error_service/sidekiq.rb#8
  def install; end

  # source://scout_apm//lib/scout_apm/error_service/sidekiq.rb#29
  def install_sidekiq_with_error_handler; end

  # source://scout_apm//lib/scout_apm/error_service/sidekiq.rb#20
  def install_sidekiq_with_middleware; end
end

# source://scout_apm//lib/scout_apm/error_service/sidekiq.rb#54
class ScoutApm::ErrorService::Sidekiq::SidekiqExceptionMiddleware
  # source://scout_apm//lib/scout_apm/error_service/sidekiq.rb#55
  def call(worker, msg, queue); end
end

# source://scout_apm//lib/scout_apm/extensions/config.rb#2
module ScoutApm::Extensions; end

# !!! Extensions are a 0.x level API and breakage is expected as the API is refined.
# Extensions fan out data collected by the agent to additional services.
#
# source://scout_apm//lib/scout_apm/extensions/config.rb#5
class ScoutApm::Extensions::Config
  # @return [Config] a new instance of Config
  #
  # source://scout_apm//lib/scout_apm/extensions/config.rb#33
  def initialize(agent_context); end

  # Returns the value of attribute agent_context.
  #
  # source://scout_apm//lib/scout_apm/extensions/config.rb#6
  def agent_context; end

  # source://scout_apm//lib/scout_apm/extensions/config.rb#81
  def logger; end

  # Returns the value of attribute periodic_callbacks.
  #
  # source://scout_apm//lib/scout_apm/extensions/config.rb#8
  def periodic_callbacks; end

  # Sets the attribute periodic_callbacks
  #
  # @param value the value to set the attribute periodic_callbacks to.
  #
  # source://scout_apm//lib/scout_apm/extensions/config.rb#8
  def periodic_callbacks=(_arg0); end

  # Runs each reporting period callback.
  # Each callback runs inside a begin/rescue block so a broken callback doesn't prevent other
  # callbacks from executing or reporting data from being sent.
  #
  # source://scout_apm//lib/scout_apm/extensions/config.rb#42
  def run_periodic_callbacks(reporting_period, metadata); end

  # Runs each transaction callback.
  # Each callback runs inside a begin/rescue block so a broken callback doesn't prevent other
  # callbacks from executing or the transaction from being recorded.
  #
  # source://scout_apm//lib/scout_apm/extensions/config.rb#59
  def run_transaction_callbacks(converter_results, context, scope_layer); end

  # Returns the value of attribute transaction_callbacks.
  #
  # source://scout_apm//lib/scout_apm/extensions/config.rb#7
  def transaction_callbacks; end

  # Sets the attribute transaction_callbacks
  #
  # @param value the value to set the attribute transaction_callbacks to.
  #
  # source://scout_apm//lib/scout_apm/extensions/config.rb#7
  def transaction_callbacks=(_arg0); end

  class << self
    # Adds a callback that runs when the per-minute report data is sent to Scout.
    # These run in a background thread so external HTTP calls are OK.
    # +callback+ must be an object that responds to a +call(reporting_period, metadata)+ method.
    #
    # Example:
    # ScoutApm::Extensions::Config.add_periodic_callback(Proc.new { |reporting_period, metadata| ... })
    #
    # source://scout_apm//lib/scout_apm/extensions/config.rb#29
    def add_periodic_callback(callback); end

    # Adds a new callback that runs after a transaction completes.
    # These run inline during the request and thus should add minimal overhead.
    # For example, a transaction callback should NOT make inline HTTP calls to outside services.
    # +callback+ must be an object that respond to a +call(payload)+ method.
    #
    # Example:
    # ScoutApm::Extensions::Config.add_transaction_callback(Proc.new { |payload| puts "Duration: #{payload.duration_ms}" })
    #
    # +payload+ is a +ScoutApm::Extensions::TransactionCallbackPayload+ object.
    #
    # source://scout_apm//lib/scout_apm/extensions/config.rb#19
    def add_transaction_callback(callback); end

    # source://scout_apm//lib/scout_apm/extensions/config.rb#77
    def agent_context; end
  end
end

# A +TransactionCallbackPayload+ is passed to each Transaction callback's +call+ method.
# It encapsulates the data about a specific transaction.
#
# source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#5
class ScoutApm::Extensions::TransactionCallbackPayload
  # @return [TransactionCallbackPayload] a new instance of TransactionCallbackPayload
  #
  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#9
  def initialize(agent_context, converter_results, context, scope_layer); end

  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#44
  def app_name; end

  # A flat hash of the context associated w/this transaction (ie user ip and another other data added to context).
  #
  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#17
  def context; end

  # A Hash that stores the output of each layer converter by name. See the naming conventions in +TrackedRequest+.
  #
  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#7
  def converter_results; end

  # A Hash that stores the output of each layer converter by name. See the naming conventions in +TrackedRequest+.
  #
  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#7
  def converter_results=(_arg0); end

  # The total duration of the transaction
  #
  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#22
  def duration_ms; end

  # Returns +true+ if the transaction raised an exception.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#49
  def error?; end

  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#40
  def hostname; end

  # The time in queue of the transaction in ms. If not present, +nil+ is returned as this is unknown.
  #
  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#27
  def queue_time_ms; end

  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#57
  def transaction_name; end

  # Web/Job are more language-agnostic names for controller/job. For example, Python Django does not have controllers.
  #
  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#62
  def transaction_type_slug; end

  # source://scout_apm//lib/scout_apm/extensions/transaction_callback_payload.rb#53
  def transation_type; end
end

# source://scout_apm//lib/scout_apm/external_service_metric_set.rb#3
class ScoutApm::ExternalServiceMetricSet
  include ::Enumerable

  # @return [ExternalServiceMetricSet] a new instance of ExternalServiceMetricSet
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#17
  def initialize(context); end

  # Add a single ExternalServiceMetricStats object to this set.
  #
  # Looks up an existing one under this key and merges, or just saves a new
  # one under the key
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#54
  def <<(stat); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#91
  def at_limit?; end

  # Take another set, and merge it with this one
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#43
  def combine!(other); end

  # Need to look this up again if we end up as nil. Which I guess can happen
  # after a Marshal load?
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#26
  def context; end

  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#30
  def each; end

  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#66
  def increment_transaction_count!; end

  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#85
  def inspect; end

  # Looks up a ExternalServiceMetricStats instance in the +@metrics+ hash. Sets the value to +other+ if no key
  # Returns a ExternalServiceMetricStats instance
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#38
  def lookup(other); end

  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#8
  def marshal_dump; end

  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#12
  def marshal_load(array); end

  # the raw metrics. You probably want #metrics_to_report
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#6
  def metrics; end

  # source://scout_apm//lib/scout_apm/external_service_metric_set.rb#72
  def metrics_to_report; end
end

# source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#2
class ScoutApm::ExternalServiceMetricStats
  # @return [ExternalServiceMetricStats] a new instance of ExternalServiceMetricStats
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#20
  def initialize(domain_name, operation, scope, call_count, call_time); end

  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#59
  def as_json; end

  # Returns the value of attribute call_count.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#12
  def call_count; end

  # Returns the value of attribute call_time.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#13
  def call_time; end

  # Combine data from another ExternalServiceMetricStats into +self+. Modifies and returns +self+
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#45
  def combine!(other); end

  # Returns the value of attribute domain_name.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#6
  def domain_name; end

  # Returns the value of attribute histogram.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#18
  def histogram; end

  # Called by the Set on each ExternalServiceMetricStats object that it holds, only
  # once during the recording of a transaction.
  #
  # Don't call elsewhere, and don't set to 1 in the initializer.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#81
  def increment_transaction_count!; end

  # Merge data in this scope. Used in ExternalServiceMetricSet
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#40
  def key; end

  # Returns the value of attribute max_call_time.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#16
  def max_call_time; end

  # Returns the value of attribute min_call_time.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#15
  def min_call_time; end

  # Returns the value of attribute operation.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#7
  def operation; end

  # Returns the value of attribute scope.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#8
  def scope; end

  # Returns the value of attribute transaction_count.
  #
  # source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#10
  def transaction_count; end
end

# source://scout_apm//lib/scout_apm/external_service_metric_stats.rb#4
ScoutApm::ExternalServiceMetricStats::DEFAULT_HISTOGRAM_SIZE = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/fake_store.rb#4
class ScoutApm::FakeStore
  # @return [FakeStore] a new instance of FakeStore
  #
  # source://scout_apm//lib/scout_apm/fake_store.rb#6
  def initialize; end

  # source://scout_apm//lib/scout_apm/fake_store.rb#44
  def add_sampler(sampler); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#9
  def current_timestamp; end

  # source://scout_apm//lib/scout_apm/fake_store.rb#47
  def tick!; end

  # source://scout_apm//lib/scout_apm/fake_store.rb#14
  def track!(metrics, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#26
  def track_db_query_metrics!(db_query_metric_set, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#29
  def track_external_service_metrics!(external_service_metric_set, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#23
  def track_histograms!(histograms, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#35
  def track_job!(job); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#17
  def track_one!(type, name, value, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#38
  def track_slow_job!(job); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#32
  def track_slow_transaction!(slow_transaction); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#20
  def track_trace!(trace, type); end

  # source://scout_apm//lib/scout_apm/fake_store.rb#41
  def write_to_layaway(layaway, force = T.unsafe(nil)); end
end

# source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#2
module ScoutApm::FrameworkIntegrations; end

# source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#3
class ScoutApm::FrameworkIntegrations::Rails2
  # source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#23
  def application_name; end

  # Attempts to determine the database engine being used
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#37
  def database_engine; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#32
  def env; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#8
  def human_name; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#4
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#16
  def present?; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#57
  def raw_database_adapter; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_2.rb#12
  def version; end
end

# source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#3
class ScoutApm::FrameworkIntegrations::Rails3Or4
  # source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#23
  def application_name; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#36
  def database_engine; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#32
  def env; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#8
  def human_name; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#4
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#16
  def present?; end

  # Note, this code intentionally avoids `.respond_to?` because of an
  # infinite loop created by the Textacular gem (tested against 3.2.2 of
  # that gem), which some customers have installed.
  #
  # The loop was:
  #   - Ask for database adapter
  #   - Do .respond_to? on AR::Base to look for connection_config (which isn't present on some versions of rails)
  #   - Textacular gem has a monkey-patch that queries the columns of the db
  #     This obtains a connection, and runs a query.
  #   - Scout tries to run SQLSanitizer against the query, which needs the database adapter.
  #   - Goes back to first step.
  #
  # We avoid this issue by not calling .respond_to? here, and instead using the less optimal `rescue nil` approach
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#73
  def raw_database_adapter; end

  # source://scout_apm//lib/scout_apm/framework_integrations/rails_3_or_4.rb#12
  def version; end
end

# source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#3
class ScoutApm::FrameworkIntegrations::Ruby
  # TODO: Fetch the name (Somehow?)
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#21
  def application_name; end

  # TODO: Figure out how to accomodate odd environments
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#30
  def database_engine; end

  # source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#25
  def env; end

  # source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#8
  def human_name; end

  # source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#4
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#16
  def present?; end

  # source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#34
  def raw_database_adapter; end

  # source://scout_apm//lib/scout_apm/framework_integrations/ruby.rb#12
  def version; end
end

# source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#3
class ScoutApm::FrameworkIntegrations::Sinatra
  # source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#20
  def application_name; end

  # TODO: Figure out how to detect this smarter
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#37
  def database_engine; end

  # source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#32
  def env; end

  # source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#8
  def human_name; end

  # source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#4
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#16
  def present?; end

  # source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#41
  def raw_database_adapter; end

  # source://scout_apm//lib/scout_apm/framework_integrations/sinatra.rb#12
  def version; end
end

# source://scout_apm//lib/scout_apm/git_revision.rb#2
class ScoutApm::GitRevision
  # @return [GitRevision] a new instance of GitRevision
  #
  # source://scout_apm//lib/scout_apm/git_revision.rb#7
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/git_revision.rb#5
  def context; end

  # source://scout_apm//lib/scout_apm/git_revision.rb#13
  def logger; end

  # Returns the value of attribute sha.
  #
  # source://scout_apm//lib/scout_apm/git_revision.rb#3
  def sha; end

  # Sets the attribute sha
  #
  # @param value the value to set the attribute sha to.
  #
  # source://scout_apm//lib/scout_apm/git_revision.rb#3
  def sha=(_arg0); end

  private

  # source://scout_apm//lib/scout_apm/git_revision.rb#64
  def app_root; end

  # source://scout_apm//lib/scout_apm/git_revision.rb#19
  def detect; end

  # source://scout_apm//lib/scout_apm/git_revision.rb#38
  def detect_from_capistrano; end

  # Config will locate the value from:
  #   ENV variable - SCOUT_REVISION_SHA
  #   YAML setting - revision_sha
  #
  # source://scout_apm//lib/scout_apm/git_revision.rb#34
  def detect_from_config; end

  # source://scout_apm//lib/scout_apm/git_revision.rb#55
  def detect_from_git; end

  # source://scout_apm//lib/scout_apm/git_revision.rb#27
  def detect_from_heroku; end

  # https://github.com/mina-deploy/mina
  #
  # source://scout_apm//lib/scout_apm/git_revision.rb#48
  def detect_from_mina; end
end

# source://scout_apm//lib/scout_apm/histogram.rb#2
class ScoutApm::HistogramBin < ::Struct
  # Returns the value of attribute count
  #
  # @return [Object] the current value of count
  def count; end

  # Sets the attribute count
  #
  # @param value [Object] the value to set the attribute count to.
  # @return [Object] the newly set value
  def count=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://scout_apm//lib/scout_apm/ignored_uris.rb#3
class ScoutApm::IgnoredUris
  # @return [IgnoredUris] a new instance of IgnoredUris
  #
  # source://scout_apm//lib/scout_apm/ignored_uris.rb#6
  def initialize(prefixes); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/ignored_uris.rb#13
  def ignore?(uri); end

  # Returns the value of attribute regex.
  #
  # source://scout_apm//lib/scout_apm/ignored_uris.rb#4
  def regex; end
end

# source://scout_apm//lib/scout_apm/instant/middleware.rb#4
module ScoutApm::Instant; end

# source://scout_apm//lib/scout_apm/instant/middleware.rb#66
class ScoutApm::Instant::DevTraceResponseManipulator
  # @return [DevTraceResponseManipulator] a new instance of DevTraceResponseManipulator
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#71
  def initialize(env, rack_response); end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#133
  def adjust_ajax_header; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#137
  def adjust_html_response; end

  # Preserve the ActionDispatch::Response object we're working with
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#169
  def adjust_newer_rails_response; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#163
  def adjust_older_rails_response; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#174
  def adjust_rack_proxy_response; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#197
  def ajax_request?; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#225
  def apm_host; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#80
  def call; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#209
  def content_type; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#121
  def dev_trace_disabled?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#201
  def development_asset?; end

  # Returns the value of attribute env.
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#69
  def env; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#180
  def html_manipulator; end

  # APM Helpers & Shorthands  #
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#217
  def logger; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#153
  def newer_rails_response?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#147
  def older_rails_response?; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#205
  def path; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#238
  def payload; end

  # Precondition checking  #
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#97
  def preconditions_met?; end

  # Returns the value of attribute rack_body.
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#68
  def rack_body; end

  # Returns the value of attribute rack_headers.
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#68
  def rack_headers; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#159
  def rack_proxy_response?; end

  # Returns the value of attribute rack_response.
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#67
  def rack_response; end

  # Returns the value of attribute rack_status.
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#68
  def rack_status; end

  # Response Injection  #
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#129
  def rebuild_rack_response; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#229
  def trace; end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#221
  def tracked_request; end
end

# Note that this middleware never even gets inserted unless Rails environment is development (See Railtie)
#
# source://scout_apm//lib/scout_apm/instant/middleware.rb#49
class ScoutApm::Instant::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#50
  def initialize(app); end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#54
  def call(env); end
end

# an abstraction for manipulating the HTML we capture in the middleware
#
# source://scout_apm//lib/scout_apm/instant/middleware.rb#7
class ScoutApm::Instant::Page
  # @return [Page] a new instance of Page
  #
  # source://scout_apm//lib/scout_apm/instant/middleware.rb#8
  def initialize(html); end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#23
  def add_to_body(content); end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#19
  def add_to_head(content); end

  # source://scout_apm//lib/scout_apm/instant/middleware.rb#27
  def res; end
end

# source://scout_apm//lib/scout_apm/instant/middleware.rb#36
class ScoutApm::Instant::Util
  class << self
    # reads the literal contents of the file in assets/#{name}
    # if any vars are supplied, do a simple string substitution of the vars for their values
    #
    # source://scout_apm//lib/scout_apm/instant/middleware.rb#39
    def read_asset(name, vars = T.unsafe(nil)); end
  end
end

# source://scout_apm//lib/scout_apm/instant_reporting.rb#5
class ScoutApm::InstantReporting
  # trace is an instance of SlowTransaction
  # instant_key is what was passed in from the browser to trigger the instant trace
  #
  # @return [InstantReporting] a new instance of InstantReporting
  #
  # source://scout_apm//lib/scout_apm/instant_reporting.rb#8
  def initialize(trace, instant_key); end

  # source://scout_apm//lib/scout_apm/instant_reporting.rb#13
  def call; end
end

# source://scout_apm//lib/scout_apm/instrument_manager.rb#2
class ScoutApm::InstrumentManager
  # @return [InstrumentManager] a new instance of InstrumentManager
  #
  # source://scout_apm//lib/scout_apm/instrument_manager.rb#7
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instrument_manager.rb#3
  def context; end

  # Loads the instrumention logic.
  #
  # source://scout_apm//lib/scout_apm/instrument_manager.rb#13
  def install!; end

  # Returns the value of attribute installed_instruments.
  #
  # source://scout_apm//lib/scout_apm/instrument_manager.rb#5
  def installed_instruments; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instrument_manager.rb#54
  def prepend_for_instrument?(instrument_klass); end

  # Allows users to skip individual instruments via the config file
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instrument_manager.rb#49
  def skip_instrument?(instrument_klass); end

  private

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instrument_manager.rb#86
  def already_installed?(instrument_klass); end

  # source://scout_apm//lib/scout_apm/instrument_manager.rb#100
  def config; end

  # source://scout_apm//lib/scout_apm/instrument_manager.rb#104
  def framework; end

  # source://scout_apm//lib/scout_apm/instrument_manager.rb#73
  def install_instrument(instrument_klass); end

  # Lookup Helpers #
  #
  # source://scout_apm//lib/scout_apm/instrument_manager.rb#96
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/net_http.rb#2
module ScoutApm::Instruments; end

# source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#154
module ScoutApm::Instruments::ActionControllerAPIInstruments
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#157
  def scout_action_name(*args); end
end

# source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#146
module ScoutApm::Instruments::ActionControllerBaseInstruments
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#149
  def scout_action_name(*args); end
end

# source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#134
module ScoutApm::Instruments::ActionControllerMetalInstruments
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#137
  def scout_action_name(*args); end
end

# source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#3
class ScoutApm::Instruments::ActionControllerRails2
  # @return [ActionControllerRails2] a new instance of ActionControllerRails2
  #
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#38
module ScoutApm::Instruments::ActionControllerRails2Instruments
  # In addition to instrumenting actions, this also sets the scope to the controller action name. The scope is later
  # applied to metrics recorded during this transaction. This lets us associate ActiveRecord calls with
  # specific controller actions.
  #
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#54
  def perform_action_with_scout_instruments(*args, &block); end

  class << self
    # @private
    #
    # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_2.rb#39
    def included(instrumented_class); end
  end
end

# instrumentation for Rails 3 and Rails 4 is the same.
#
# source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#4
class ScoutApm::Instruments::ActionControllerRails3Rails4
  # @return [ActionControllerRails3Rails4] a new instance of ActionControllerRails3Rails4
  #
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#7
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#5
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#24
  def install(prepend:); end

  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#20
  def installed!; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#16
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#12
  def logger; end

  class << self
    # Returns a new anonymous module each time it is called. So
    # we can insert this multiple times into the ancestors
    # stack. Otherwise it only exists the first time you include it
    # (under Metal, instead of under API) and we miss instrumenting
    # before_action callbacks
    #
    # source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#75
    def build_instrument_module; end
  end
end

# Empty, noop module to provide compatibility w/ previous manual instrumentation
#
# source://scout_apm//lib/scout_apm/instruments/action_controller_rails_3_rails4.rb#143
module ScoutApm::Instruments::ActionControllerRails3Rails4Instruments; end

# source://scout_apm//lib/scout_apm/instruments/action_view.rb#12
class ScoutApm::Instruments::ActionView
  # @return [ActionView] a new instance of ActionView
  #
  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#15
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#13
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#32
  def install(prepend:); end

  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#69
  def install_using_prepend; end

  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#43
  def install_using_tracer; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#24
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#20
  def logger; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#28
  def prependable?; end
end

# source://scout_apm//lib/scout_apm/instruments/action_view.rb#77
module ScoutApm::Instruments::ActionView::ActionViewPartialRendererInstruments
  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#105
  def collection_with_template(*args, **kwargs); end

  # In Rails 6, the signature changed to pass the view & template args directly, as opposed to through the instance var
  # New signature is: def render_partial(view, template)
  #
  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#80
  def render_partial(*args, **kwargs); end
end

# source://scout_apm//lib/scout_apm/instruments/action_view.rb#131
module ScoutApm::Instruments::ActionView::ActionViewTemplateRendererInstruments
  # Don't forward kwargs here, since Rails 3, 4, 5, 6 don't use them, and
  # it causes annoyances in the instrumentation
  #
  # source://scout_apm//lib/scout_apm/instruments/action_view.rb#134
  def render_template(*args); end
end

# source://scout_apm//lib/scout_apm/instruments/active_record.rb#37
class ScoutApm::Instruments::ActiveRecord
  # @return [ActiveRecord] a new instance of ActiveRecord
  #
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#40
  def initialize(context); end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#73
  def add_instruments; end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#38
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#53
  def install(prepend:); end

  # If we have the right version of rails, we should use the hooks provided
  # to install these instruments
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#65
  def install_via_after_initialize?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#49
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#45
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/active_record.rb#332
module ScoutApm::Instruments::ActiveRecordFinderMethodsInstruments
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#343
  def find_with_associations_with_scout_instruments(*args, &block); end

  class << self
    # @private
    #
    # source://scout_apm//lib/scout_apm/instruments/active_record.rb#333
    def included(instrumented_class); end
  end
end

# Contains ActiveRecord instrument, aliasing +ActiveRecord::ConnectionAdapters::AbstractAdapter#log+ calls
# to trace calls to the database.
#
# #log instrument.
#
# #log is very close to where AR calls out to the database itself.  We have access
# to the real SQL, and an AR generated "name" for the Query
#
# source://scout_apm//lib/scout_apm/instruments/active_record.rb#168
module ScoutApm::Instruments::ActiveRecordInstruments
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#226
  def log(*args, **_arg1, &block); end

  class << self
    # source://scout_apm//lib/scout_apm/instruments/active_record.rb#222
    def prepended(instrumented_class); end
  end
end

# Entry-point of instruments.
#
# Instrumentation starts in ActiveRecord::Relation#exec_queries (Rails >=
# 3.2.0) or ActiveRecord::FinderMethods#find_with_assocations (previous
# Rails versions).
#
# ActiveRecord::Querying#find_by_sql is instrumented in all Rails versions
# even though it is also invoked by #exec_queries/#find_by_associations
# because it can be invoked directly from user code (e.g.,
# Post.find_by_sql("SELECT * FROM posts")). The layer started by
# #exec_queries/#find_by_assocations is marked to ignore children, so it
# will not cause duplicate layers in the former case.
#
# These methods are early in the chain of calls invoked when executing an
# ActiveRecord query, before the cache is consulted. If the query is later
# determined to be a cache miss, `#log` will be invoked, which we also
# instrument, and more details will be filled in (name, sql).
#
# Caveats:
#   * We don't have a name for the query yet.
#   * The query hasn't hit the cache yet. In the case of a cache hit, we
#     won't hit #log, so won't get a name, leaving the misleading default.
#   * One call here can result in several calls to #log, especially in the
#     case where Rails needs to load the schema details for the table being
#     queried.
#
# source://scout_apm//lib/scout_apm/instruments/active_record.rb#302
module ScoutApm::Instruments::ActiveRecordQueryingInstruments
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#313
  def find_by_sql_with_scout_instruments(*args, **kwargs, &block); end

  class << self
    # @private
    #
    # source://scout_apm//lib/scout_apm/instruments/active_record.rb#303
    def included(instrumented_class); end
  end
end

# source://scout_apm//lib/scout_apm/instruments/active_record.rb#436
module ScoutApm::Instruments::ActiveRecordRelationInstruments
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#465
  def delete_all_with_scout_instruments(*args, &block); end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#480
  def destroy_all_with_scout_instruments(*args, &block); end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#450
  def update_all_with_scout_instruments(*args, &block); end

  class << self
    # @private
    #
    # source://scout_apm//lib/scout_apm/instruments/active_record.rb#437
    def included(instrumented_class); end
  end
end

# source://scout_apm//lib/scout_apm/instruments/active_record.rb#359
module ScoutApm::Instruments::ActiveRecordRelationQueryInstruments
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#374
  def exec_queries(*args, &block); end

  class << self
    # @private
    #
    # source://scout_apm//lib/scout_apm/instruments/active_record.rb#364
    def included(instrumented_class); end

    # source://scout_apm//lib/scout_apm/instruments/active_record.rb#360
    def prepended(instrumented_class); end
  end
end

# source://scout_apm//lib/scout_apm/instruments/active_record.rb#401
module ScoutApm::Instruments::ActiveRecordUpdateInstruments
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#402
  def save(*args, **options, &block); end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#419
  def save!(*args, **options, &block); end
end

class ScoutApm::Instruments::Allocations
  class << self
    def count; end
  end
end

ScoutApm::Instruments::Allocations::ENABLED = T.let(T.unsafe(nil), TrueClass)

# source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#5
class ScoutApm::Instruments::Elasticsearch
  # @return [Elasticsearch] a new instance of Elasticsearch
  #
  # source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#8
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#6
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#21
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#17
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#13
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#87
module ScoutApm::Instruments::ElasticsearchTransportClientInstrumentationPrepend
  # source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#96
  def _sanitize_name(name); end

  # source://scout_apm//lib/scout_apm/instruments/elasticsearch.rb#88
  def perform_request(*args, &block); end
end

# source://scout_apm//lib/scout_apm/instruments/grape.rb#3
class ScoutApm::Instruments::Grape
  # @return [Grape] a new instance of Grape
  #
  # source://scout_apm//lib/scout_apm/instruments/grape.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/grape.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/grape.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/grape.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/grape.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/grape.rb#35
module ScoutApm::Instruments::GrapeEndpointInstruments
  # source://scout_apm//lib/scout_apm/instruments/grape.rb#36
  def run_with_scout_instruments(*args); end
end

# source://scout_apm//lib/scout_apm/instruments/http.rb#3
class ScoutApm::Instruments::HTTP
  # @return [HTTP] a new instance of HTTP
  #
  # source://scout_apm//lib/scout_apm/instruments/http.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/http.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/http.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/http.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/http.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/http.rb#53
module ScoutApm::Instruments::HTTPInstrumentationPrepend
  # source://scout_apm//lib/scout_apm/instruments/http.rb#54
  def request(verb, uri, opts = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/instruments/http.rb#60
  def request_scout_description(verb, uri); end
end

# source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#4
class ScoutApm::Instruments::HistogramReport
  # @return [HistogramReport] a new instance of HistogramReport
  #
  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#8
  def initialize(name, histogram); end

  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#13
  def combine!(other); end

  # Returns the value of attribute histogram.
  #
  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#6
  def histogram; end

  # Returns the value of attribute name.
  #
  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#5
  def name; end
end

# source://scout_apm//lib/scout_apm/instruments/http_client.rb#3
class ScoutApm::Instruments::HttpClient
  # @return [HttpClient] a new instance of HttpClient
  #
  # source://scout_apm//lib/scout_apm/instruments/http_client.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/http_client.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/http_client.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/http_client.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/http_client.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/http_client.rb#53
module ScoutApm::Instruments::HttpClientInstrumentationPrepend
  # source://scout_apm//lib/scout_apm/instruments/http_client.rb#54
  def request(*args, &block); end
end

# source://scout_apm//lib/scout_apm/instruments/influxdb.rb#3
class ScoutApm::Instruments::InfluxDB
  # @return [InfluxDB] a new instance of InfluxDB
  #
  # source://scout_apm//lib/scout_apm/instruments/influxdb.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/influxdb.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/influxdb.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/influxdb.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/influxdb.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/memcached.rb#3
class ScoutApm::Instruments::Memcached
  # @return [Memcached] a new instance of Memcached
  #
  # source://scout_apm//lib/scout_apm/instruments/memcached.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/memcached.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/memcached.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/memcached.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/memcached.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/memcached.rb#48
module ScoutApm::Instruments::MemcachedInstrumentationPrepend
  # source://scout_apm//lib/scout_apm/instruments/memcached.rb#49
  def perform(*args, &block); end
end

# source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#11
class ScoutApm::Instruments::MiddlewareDetailed
  # @return [MiddlewareDetailed] a new instance of MiddlewareDetailed
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#14
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#12
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#27
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#23
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#19
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#41
class ScoutApm::Instruments::MiddlewareDetailed::MiddlewareWrapper
  # @return [MiddlewareWrapper] a new instance of MiddlewareWrapper
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#42
  def initialize(app, name); end

  # source://scout_apm//lib/scout_apm/instruments/middleware_detailed.rb#48
  def call(env); end
end

# source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#8
class ScoutApm::Instruments::MiddlewareSummary
  # @return [MiddlewareSummary] a new instance of MiddlewareSummary
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#11
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#9
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#24
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#20
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#16
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#49
class ScoutApm::Instruments::MiddlewareSummary::MiddlewareSummaryWrapper
  # @return [MiddlewareSummaryWrapper] a new instance of MiddlewareSummaryWrapper
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#50
  def initialize(app); end

  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#54
  def call(env); end

  # Some code (found in resque_web initially) attempts to call methods
  # directly on `MyApplication.app`, which is the middleware stack.
  # If it hits our middleware instead of the object at the root of the
  # app that it expected, then a method it expects will not be there, and an
  # error thrown.
  #
  # Specifically, resque_web assumes `ResqueWeb::Engine.app.url_helpers`
  # is a method call on rails router for its own Engine, when in fact,
  # we've added a middleware before it.
  #
  # So method_missing just proxies anything to the nested @app object
  #
  # While method_missing is not very performant, this is only here to
  # handle edge-cases in other code, and should not be regularly called
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#77
  def method_missing(sym, *arguments, &block); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/middleware_summary.rb#85
  def respond_to?(sym, include_private = T.unsafe(nil)); end
end

# source://scout_apm//lib/scout_apm/instruments/mongoid.rb#3
class ScoutApm::Instruments::Mongoid
  # @return [Mongoid] a new instance of Mongoid
  #
  # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#11
  def logger; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#97
  def mongoid_v5?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#105
  def mongoid_v6?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#113
  def mongoid_v7?; end

  class << self
    # Example of what a filter looks like: => {"founded"=>{"$gte"=>"1980-1-1"}, "name"=>{"$in"=>["Tool", "Deftones", "Melvins"]}}
    # Approach: find every leaf-node, clear it. inspect the whole thing when done.
    #
    # source://scout_apm//lib/scout_apm/instruments/mongoid.rb#123
    def anonymize_filter(filter); end
  end
end

# source://scout_apm//lib/scout_apm/instruments/moped.rb#3
class ScoutApm::Instruments::Moped
  # @return [Moped] a new instance of Moped
  #
  # source://scout_apm//lib/scout_apm/instruments/moped.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/moped.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/moped.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/moped.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/moped.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/moped.rb#58
module ScoutApm::Instruments::MopedInstrumentationPrepend
  # source://scout_apm//lib/scout_apm/instruments/moped.rb#59
  def process(operation, &callback); end

  # replaces values w/ ?
  #
  # source://scout_apm//lib/scout_apm/instruments/moped.rb#70
  def scout_sanitize_log(log); end
end

# source://scout_apm//lib/scout_apm/instruments/net_http.rb#3
class ScoutApm::Instruments::NetHttp
  # @return [NetHttp] a new instance of NetHttp
  #
  # source://scout_apm//lib/scout_apm/instruments/net_http.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/net_http.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/net_http.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/net_http.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/net_http.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/net_http.rb#61
module ScoutApm::Instruments::NetHttpInstrumentationPrepend
  # source://scout_apm//lib/scout_apm/instruments/net_http.rb#62
  def request(request, *args, &block); end

  # source://scout_apm//lib/scout_apm/instruments/net_http.rb#68
  def request_scout_description(req); end
end

# source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#20
class ScoutApm::Instruments::PercentileSampler
  # @return [PercentileSampler] a new instance of PercentileSampler
  #
  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#21
  def initialize(context); end

  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#25
  def histograms; end

  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#33
  def human_name; end

  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#29
  def logger; end

  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#37
  def metrics(timestamp, store); end

  # source://scout_apm//lib/scout_apm/instruments/percentile_sampler.rb#41
  def percentiles(time); end
end

# source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#3
module ScoutApm::Instruments::Process; end

# source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#4
class ScoutApm::Instruments::Process::ProcessCpu
  # @return [ProcessCpu] a new instance of ProcessCpu
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#9
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#7
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#28
  def human_name; end

  # Returns the value of attribute last_run.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#6
  def last_run; end

  # Sets the attribute last_run
  #
  # @param value the value to set the attribute last_run to.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#6
  def last_run=(_arg0); end

  # Returns the value of attribute last_stime.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#6
  def last_stime; end

  # Sets the attribute last_stime
  #
  # @param value the value to set the attribute last_stime to.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#6
  def last_stime=(_arg0); end

  # Returns the value of attribute last_utime.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#6
  def last_utime; end

  # Sets the attribute last_utime
  #
  # @param value the value to set the attribute last_utime to.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#6
  def last_utime=(_arg0); end

  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#102
  def logger; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#24
  def metric_name; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#20
  def metric_type; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#32
  def metrics(timestamp, store); end

  # Returns the value of attribute num_processors.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#5
  def num_processors; end

  # TODO: Figure out a good default instead of nil
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#46
  def run; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_cpu.rb#96
  def save_times(now, utime, stime); end
end

# source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#4
class ScoutApm::Instruments::Process::ProcessMemory
  # @return [ProcessMemory] a new instance of ProcessMemory
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#21
  def initialize(context); end

  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#33
  def human_name; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#53
  def logger; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#29
  def metric_name; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#25
  def metric_type; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#37
  def metrics(timestamp, store); end

  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#13
  def rss; end

  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#17
  def rss_in_mb; end

  # Account for Darwin returning maxrss in bytes and Linux in KB. Used by
  # the slow converters. Doesn't feel like this should go here
  # though...more of a utility.
  #
  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#8
  def rss_to_mb(rss); end

  # source://scout_apm//lib/scout_apm/instruments/process/process_memory.rb#49
  def run; end
end

# source://scout_apm//lib/scout_apm/instruments/rails_router.rb#3
class ScoutApm::Instruments::RailsRouter
  # @return [RailsRouter] a new instance of RailsRouter
  #
  # source://scout_apm//lib/scout_apm/instruments/rails_router.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/rails_router.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/rails_router.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/rails_router.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/rails_router.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/redis.rb#3
class ScoutApm::Instruments::Redis
  # @return [Redis] a new instance of Redis
  #
  # source://scout_apm//lib/scout_apm/instruments/redis.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/redis.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/redis.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/redis.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/redis.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/redis5.rb#3
class ScoutApm::Instruments::Redis5
  # @return [Redis5] a new instance of Redis5
  #
  # source://scout_apm//lib/scout_apm/instruments/redis5.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/redis5.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/redis5.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/redis5.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/redis5.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/redis5.rb#48
module ScoutApm::Instruments::Redis5ClientInstrumentationPrepend
  # source://scout_apm//lib/scout_apm/instruments/redis5.rb#49
  def call(args, &block); end
end

# source://scout_apm//lib/scout_apm/instruments/redis.rb#48
module ScoutApm::Instruments::RedisClientInstrumentationPrepend
  # source://scout_apm//lib/scout_apm/instruments/redis.rb#49
  def call(*args, &block); end
end

# source://scout_apm//lib/scout_apm/instruments/resque.rb#3
module ScoutApm::Instruments::Resque
  # source://scout_apm//lib/scout_apm/instruments/resque.rb#4
  def around_perform_with_scout_instruments(*args); end

  # source://scout_apm//lib/scout_apm/instruments/resque.rb#31
  def find_queue; end
end

# source://scout_apm//lib/scout_apm/instruments/samplers.rb#3
class ScoutApm::Instruments::Samplers; end

# source://scout_apm//lib/scout_apm/instruments/samplers.rb#4
ScoutApm::Instruments::Samplers::DEFAULT_SAMPLERS = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/instruments/sinatra.rb#6
class ScoutApm::Instruments::Sinatra
  # source://scout_apm//lib/scout_apm/instruments/sinatra.rb#9
  def initalize(logger = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/instruments/sinatra.rb#18
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/sinatra.rb#14
  def installed?; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/instruments/sinatra.rb#7
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/sinatra.rb#33
module ScoutApm::Instruments::SinatraInstruments
  # source://scout_apm//lib/scout_apm/instruments/sinatra.rb#34
  def dispatch_with_scout_instruments!; end

  # Iterates through the app's routes, returning the matched route that the request should be
  # grouped under for the metric name.
  #
  # If not found, "unknown" is returned. This prevents a metric explosion.
  #
  # Nice to have: substitute the param pattern (([^/?#]+)) w/the named key (the +key+ param of the block).
  #
  # source://scout_apm//lib/scout_apm/instruments/sinatra.rb#59
  def scout_sinatra_controller_name(request); end
end

# source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#3
class ScoutApm::Instruments::Typhoeus
  # @return [Typhoeus] a new instance of Typhoeus
  #
  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#19
  def install(prepend:); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#15
  def installed?; end

  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#11
  def logger; end
end

# source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#30
module ScoutApm::Instruments::Typhoeus::TyphoeusHydraInstrumentation
  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#31
  def run(*args, &block); end

  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#45
  def scout_desc; end
end

# source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#52
module ScoutApm::Instruments::Typhoeus::TyphoeusInstrumentation
  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#53
  def run(*args, &block); end

  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#67
  def scout_desc(verb, uri); end

  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#74
  def scout_request_url; end

  # source://scout_apm//lib/scout_apm/instruments/typhoeus.rb#80
  def scout_request_verb; end
end

# source://scout_apm//lib/scout_apm/job_record.rb#9
class ScoutApm::JobRecord
  # @return [JobRecord] a new instance of JobRecord
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#17
  def initialize(queue_name, job_name, total_time, exclusive_time, errors, metrics); end

  # Hash Key interface
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#61
  def ==(o); end

  # Modifies self and returns self, after merging in `other`.
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#34
  def combine!(other); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#71
  def eql?(o); end

  # Returns the value of attribute errors.
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#14
  def errors; end

  # Returns the value of attribute exclusive_time.
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#13
  def exclusive_time; end

  # source://scout_apm//lib/scout_apm/job_record.rb#65
  def hash; end

  # Returns the value of attribute job_name.
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#11
  def job_name; end

  # Returns the value of attribute metric_set.
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#15
  def metric_set; end

  # source://scout_apm//lib/scout_apm/job_record.rb#52
  def metrics; end

  # Returns the value of attribute queue_name.
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#10
  def queue_name; end

  # source://scout_apm//lib/scout_apm/job_record.rb#48
  def run_count; end

  # Returns the value of attribute total_time.
  #
  # source://scout_apm//lib/scout_apm/job_record.rb#12
  def total_time; end
end

# source://scout_apm//lib/scout_apm/layaway.rb#9
class ScoutApm::Layaway
  # @return [Layaway] a new instance of Layaway
  #
  # source://scout_apm//lib/scout_apm/layaway.rb#22
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/layaway.rb#21
  def context; end

  # source://scout_apm//lib/scout_apm/layaway.rb#131
  def delete_files_for(timestamp); end

  # source://scout_apm//lib/scout_apm/layaway.rb#138
  def delete_stale_files(older_than); end

  # Returns a Pathname object with the fully qualified directory where the layaway files can be placed.
  # That directory must be writable by this process.
  #
  # Don't set this in initializer, since it relies on agent instance existing to figure out the value.
  #
  # source://scout_apm//lib/scout_apm/layaway.rb#35
  def directory; end

  # source://scout_apm//lib/scout_apm/layaway.rb#26
  def logger; end

  # Claims a given timestamp by getting an exclusive lock on a timestamped
  # coordinator file. The coordinator file never contains data, it's just a
  # syncronization mechanism.
  #
  # Once the 'claim' is obtained:
  #   * load and yield each ReportingPeriod from the layaway files.
  #   * if there are reporting periods:
  #     * yields any ReportingPeriods collected up from all the files.
  #     * deletes all of the layaway files (including the coordinator) for the timestamp
  #   * if not
  #     * delete the coordinator
  #   * remove any stale layaway files that may be hanging around.
  #   * Finally unlock and ensure the coordinator file is cleared.
  #
  # If a claim file can't be obtained, return false without doing any work
  # Another process is handling the reporting.
  #
  # source://scout_apm//lib/scout_apm/layaway.rb#83
  def with_claim(timestamp); end

  # source://scout_apm//lib/scout_apm/layaway.rb#52
  def write_reporting_period(reporting_period, files_limit = T.unsafe(nil)); end

  private

  # source://scout_apm//lib/scout_apm/layaway.rb#159
  def all_files_for(timestamp); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layaway.rb#199
  def at_layaway_file_limit?(files_limit = T.unsafe(nil)); end

  # Looking up files
  #
  # source://scout_apm//lib/scout_apm/layaway.rb#155
  def file_for(timestamp); end

  # source://scout_apm//lib/scout_apm/layaway.rb#182
  def format_pid(pid); end

  # source://scout_apm//lib/scout_apm/layaway.rb#172
  def format_timestamp(timestamp); end

  # Timestamp should be either :all or a Time-ish object that responds to strftime (StoreReportingPeriodTimestamp does)
  # if timestamp == :all then find all timestamps, otherwise format it.
  # if pid == :all, get the files for all
  #
  # source://scout_apm//lib/scout_apm/layaway.rb#166
  def glob_pattern(timestamp, pid = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/layaway.rb#203
  def log_layaway_file_information; end

  # source://scout_apm//lib/scout_apm/layaway.rb#190
  def timestamp_from_filename(filename); end
end

# Failsafe to prevent writing layaway files if for some reason they are not being cleaned up
#
# source://scout_apm//lib/scout_apm/layaway.rb#15
ScoutApm::Layaway::MAX_FILES_LIMIT = T.let(T.unsafe(nil), Integer)

# How long to let a stale file sit before deleting it.
# Letting it sit a bit may be useful for debugging
#
# source://scout_apm//lib/scout_apm/layaway.rb#12
ScoutApm::Layaway::STALE_AGE = T.let(T.unsafe(nil), Integer)

# A strftime format string for how we render timestamps in filenames.
# Must be sortable as an integer
#
# source://scout_apm//lib/scout_apm/layaway.rb#19
ScoutApm::Layaway::TIME_FORMAT = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/layaway_file.rb#3
class ScoutApm::LayawayFile
  # @return [LayawayFile] a new instance of LayawayFile
  #
  # source://scout_apm//lib/scout_apm/layaway_file.rb#7
  def initialize(context, path); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/layaway_file.rb#5
  def context; end

  # source://scout_apm//lib/scout_apm/layaway_file.rb#39
  def deserialize(data); end

  # source://scout_apm//lib/scout_apm/layaway_file.rb#16
  def load; end

  # source://scout_apm//lib/scout_apm/layaway_file.rb#12
  def logger; end

  # Returns the value of attribute path.
  #
  # source://scout_apm//lib/scout_apm/layaway_file.rb#4
  def path; end

  # source://scout_apm//lib/scout_apm/layaway_file.rb#43
  def read_raw(f); end

  # source://scout_apm//lib/scout_apm/layaway_file.rb#31
  def serialize(data); end

  # source://scout_apm//lib/scout_apm/layaway_file.rb#26
  def write(data); end

  # source://scout_apm//lib/scout_apm/layaway_file.rb#55
  def write_raw(f, data); end
end

# source://scout_apm//lib/scout_apm/layer.rb#2
class ScoutApm::Layer
  # @return [Layer] a new instance of Layer
  #
  # source://scout_apm//lib/scout_apm/layer.rb#56
  def initialize(type, name, start_time = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/layer.rb#73
  def add_child(child); end

  # Returns the value of attribute allocations_start.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#52
  def allocations_start; end

  # Returns the value of attribute allocations_stop.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#52
  def allocations_stop; end

  # This data is internal to ScoutApm, to add custom information, use the Context api.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#92
  def annotate_layer(hsh); end

  # As we go through a part of a request, instrumentation can store additional data
  # Known Keys:
  #   :record_count - The number of rows returned by an AR query (From notification instantiation.active_record)
  #   :class_name   - The ActiveRecord class name (From notification instantiation.active_record)
  #
  # If no annotations are ever set, this will return nil
  #
  # source://scout_apm//lib/scout_apm/layer.rb#50
  def annotations; end

  # If this layer took longer than a fixed amount of time, store the
  # backtrace of where it occurred.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#39
  def backtrace; end

  # If this layer took longer than a fixed amount of time, store the
  # backtrace of where it occurred.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#39
  def backtrace=(_arg0); end

  # In Ruby 2.0+, we can pass the range directly to the caller to reduce the memory footprint.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#117
  def caller_array; end

  # source://scout_apm//lib/scout_apm/layer.rb#112
  def capture_backtrace!; end

  # An array of children layers
  # For instance, if we are in a middleware, there will likely be only a single
  # child, which is another middleware.  In a Controller, we may have a handful
  # of children: [ActiveRecord, ActiveRecord, View, HTTP Call].
  #
  # This useful to get actual time spent in this layer vs. children time
  #
  # TODO: Check callers for compatibility w/ nil to avoid making an empty array
  #
  # source://scout_apm//lib/scout_apm/layer.rb#24
  def children; end

  # The description of this layer.  Will contain additional details specific to the type of layer.
  # For an ActiveRecord metric, it will contain the SQL run
  # For an outoing HTTP call, it will contain the remote URL accessed
  # Leave blank if there is nothing to note
  #
  # source://scout_apm//lib/scout_apm/layer.rb#35
  def desc; end

  # source://scout_apm//lib/scout_apm/layer.rb#87
  def desc=(desc); end

  # The file name associated with the layer. Only used for autoinstruments overhead logging.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#42
  def file_name; end

  # The file name associated with the layer. Only used for autoinstruments overhead logging.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#42
  def file_name=(_arg0); end

  # This is the old style name. This function is used for now, but should be
  # removed, and the new type & name split should be enforced through the
  # app.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#108
  def legacy_metric_name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer.rb#69
  def limited?; end

  # Name: a more specific name of this single item
  #   Examples: "Rack::Cache", "User#find", "users/index", "users/index.html.erb"
  #
  # Accessor, so we can update a layer if multiple pieces of instrumentation work
  #   together at different layers to fill in the full data. See the ActiveRecord
  #   instrumentation for an example of how this is useful
  #
  # source://scout_apm//lib/scout_apm/layer.rb#14
  def name; end

  # Name: a more specific name of this single item
  #   Examples: "Rack::Cache", "User#find", "users/index", "users/index.html.erb"
  #
  # Accessor, so we can update a layer if multiple pieces of instrumentation work
  #   together at different layers to fill in the full data. See the ActiveRecord
  #   instrumentation for an example of how this is useful
  #
  # source://scout_apm//lib/scout_apm/layer.rb#14
  def name=(_arg0); end

  # Fetch the current number of allocated objects. This will always increment - we fetch when initializing and when stopping the layer.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#83
  def record_allocations!; end

  # source://scout_apm//lib/scout_apm/layer.rb#78
  def record_stop_time!(stop_time = T.unsafe(nil)); end

  # Time objects recording the start & stop times of this layer
  #
  # source://scout_apm//lib/scout_apm/layer.rb#29
  def start_time; end

  # Time objects recording the start & stop times of this layer
  #
  # source://scout_apm//lib/scout_apm/layer.rb#29
  def stop_time; end

  # source://scout_apm//lib/scout_apm/layer.rb#97
  def subscopable!; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer.rb#101
  def subscopable?; end

  # May not be safe to call in every rails app, relies on Time#iso8601
  #
  # source://scout_apm//lib/scout_apm/layer.rb#131
  def to_s; end

  # These are almost identical to the timing metrics.
  #
  # source://scout_apm//lib/scout_apm/layer.rb#174
  def total_allocations; end

  # Time Calculations
  #
  # source://scout_apm//lib/scout_apm/layer.rb#149
  def total_call_time; end

  # source://scout_apm//lib/scout_apm/layer.rb#183
  def total_exclusive_allocations; end

  # source://scout_apm//lib/scout_apm/layer.rb#157
  def total_exclusive_time; end

  # Type: a general name for the kind of thing being tracked.
  #   Examples: "Middleware", "ActiveRecord", "Controller", "View"
  #
  # source://scout_apm//lib/scout_apm/layer.rb#6
  def type; end

  private

  # source://scout_apm//lib/scout_apm/layer.rb#187
  def child_allocations; end

  # source://scout_apm//lib/scout_apm/layer.rb#161
  def child_time; end
end

# maximum number of lines to send thru for backtrace analysis
#
# source://scout_apm//lib/scout_apm/layer.rb#54
ScoutApm::Layer::BACKTRACE_CALLER_LIMIT = T.let(T.unsafe(nil), Integer)

# A set of children records for any given Layer.  This implements some
# rate-limiting logic.
#
# We store the first `unique_cutoff` count of each layer type. So if cutoff
# is 1000, we'd store 1000 HTTP layers, and 1000 ActiveRecord calls, and 1000
# of each other layer type. After that, make a LimitedLayer object and store
# only aggregate counts and times of future layers of that type. (So the
# 1001st an onward of ActiveRecord would get only aggregate times, and
# counts, without any detail about the SQL called)
#
# When the set of children is small, keep them unique
# When the set of children gets large enough, stop keeping details
#
# The next optimization, which is not yet implemented:
#   when the set of children gets larger, attempt to merge them without data loss
#
# source://scout_apm//lib/scout_apm/layer_children_set.rb#17
class ScoutApm::LayerChildrenSet
  include ::Enumerable

  # @return [LayerChildrenSet] a new instance of LayerChildrenSet
  #
  # source://scout_apm//lib/scout_apm/layer_children_set.rb#29
  def initialize(unique_cutoff = T.unsafe(nil)); end

  # Add a new layer into this set
  # Only add completed layers - otherwise this will collect up incorrect info
  # into the created LimitedLayer, since it will "freeze" any current data for
  # total_call_time and similar methods.
  #
  # source://scout_apm//lib/scout_apm/layer_children_set.rb#44
  def <<(child); end

  # source://scout_apm//lib/scout_apm/layer_children_set.rb#35
  def child_set(metric_type); end

  # source://scout_apm//lib/scout_apm/layer_children_set.rb#64
  def each; end

  # source://scout_apm//lib/scout_apm/layer_children_set.rb#78
  def length; end

  # source://scout_apm//lib/scout_apm/layer_children_set.rb#82
  def size; end

  # Returns the value of attribute unique_cutoff.
  #
  # source://scout_apm//lib/scout_apm/layer_children_set.rb#23
  def unique_cutoff; end

  private

  # The Set of children objects
  #
  # source://scout_apm//lib/scout_apm/layer_children_set.rb#26
  def children; end
end

# By default, how many unique children of a type do we store before
# flipping over to storing only aggregate info.
#
# source://scout_apm//lib/scout_apm/layer_children_set.rb#22
ScoutApm::LayerChildrenSet::DEFAULT_UNIQUE_CUTOFF = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#2
module ScoutApm::LayerConverters; end

# source://scout_apm//lib/scout_apm/layer_converters/allocation_metric_converter.rb#3
class ScoutApm::LayerConverters::AllocationMetricConverter < ::ScoutApm::LayerConverters::ConverterBase
  # source://scout_apm//lib/scout_apm/layer_converters/allocation_metric_converter.rb#4
  def record!; end
end

# source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#3
class ScoutApm::LayerConverters::ConverterBase
  # @return [ConverterBase] a new instance of ConverterBase
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#10
  def initialize(context, request, layer_finder, store = T.unsafe(nil)); end

  # Call this after you finish walking the layers, and want to take the
  # set-aside backtraces and place them into the metas they match
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#86
  def attach_backtraces(metric_hash); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#5
  def context; end

  # Returns the value of attribute layer_finder.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#8
  def layer_finder; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#113
  def limited?; end

  # When we make MetricMeta records, we need to determine a few things from layer.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#122
  def make_meta_options(layer); end

  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#148
  def make_meta_options_desc_hash(layer, max_desc_length = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#129
  def make_meta_options_scope(layer); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#105
  def over_metric_limit?(metric_hash); end

  # Subscoping
  #
  #
  # Keep a list of subscopes, but only ever use the front one.  The rest
  # get pushed/popped in cases when we have many levels of subscopable
  # layers.  This lets us push/pop without otherwise keeping track very closely.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#32
  def register_hooks(walker); end

  # Returns the value of attribute request.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#6
  def request; end

  # Returns the value of attribute root_layer.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#7
  def root_layer; end

  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#21
  def scope_layer; end

  # Sometimes we start capturing a layer without knowing if we really
  # want to make an entry for it.  See ActiveRecord instrumentation for
  # an example. We start capturing before we know if a query is cached
  # or not, and want to skip any cached queries.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#215
  def skip_layer?(layer); end

  # Merged Metric - no specifics, just sum up by type (ActiveRecord, View, HTTP, etc)
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#192
  def store_aggregate_metric(layer, metric_hash, allocation_metric_hash); end

  # Call this as you are processing each layer. It will store off backtraces
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#74
  def store_backtrace(layer, meta); end

  # This is the detailed metric - type, name, backtrace, annotations, etc.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#164
  def store_specific_metric(layer, metric_hash, allocation_metric_hash); end

  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#52
  def subscope_name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#48
  def subscoped?(layer); end
end

# To prevent huge traces from being generated, we should stop collecting
# detailed metrics as we go beyond some reasonably large count.
#
# We should still add up the /all aggregates.
#
# source://scout_apm//lib/scout_apm/layer_converters/converter_base.rb#103
ScoutApm::LayerConverters::ConverterBase::MAX_METRICS = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#3
class ScoutApm::LayerConverters::DatabaseConverter < ::ScoutApm::LayerConverters::ConverterBase
  # @return [DatabaseConverter] a new instance of DatabaseConverter
  #
  # source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#4
  def initialize(*_arg0); end

  # source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#28
  def record!; end

  # source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#9
  def register_hooks(walker); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#38
  def skip_layer?(layer); end

  private

  # source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#53
  def model_name(layer); end

  # source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#57
  def operation_name(layer); end

  # source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#61
  def records_returned(layer); end
end

# If we can't name the model, default to:
#
# source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#48
ScoutApm::LayerConverters::DatabaseConverter::DEFAULT_MODEL = T.let(T.unsafe(nil), String)

# If we can't name the operation, default to:
#
# source://scout_apm//lib/scout_apm/layer_converters/database_converter.rb#51
ScoutApm::LayerConverters::DatabaseConverter::DEFAULT_OPERATION = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/layer_converters/depth_first_walker.rb#3
class ScoutApm::LayerConverters::DepthFirstWalker
  # @return [DepthFirstWalker] a new instance of DepthFirstWalker
  #
  # source://scout_apm//lib/scout_apm/layer_converters/depth_first_walker.rb#6
  def initialize(root_layer); end

  # source://scout_apm//lib/scout_apm/layer_converters/depth_first_walker.rb#18
  def after(&block); end

  # source://scout_apm//lib/scout_apm/layer_converters/depth_first_walker.rb#14
  def before(&block); end

  # source://scout_apm//lib/scout_apm/layer_converters/depth_first_walker.rb#22
  def on(&block); end

  # Returns the value of attribute root_layer.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/depth_first_walker.rb#4
  def root_layer; end

  # source://scout_apm//lib/scout_apm/layer_converters/depth_first_walker.rb#26
  def walk(layer = T.unsafe(nil)); end
end

# source://scout_apm//lib/scout_apm/layer_converters/error_converter.rb#3
class ScoutApm::LayerConverters::ErrorConverter < ::ScoutApm::LayerConverters::ConverterBase
  # source://scout_apm//lib/scout_apm/layer_converters/error_converter.rb#4
  def record!; end
end

# source://scout_apm//lib/scout_apm/layer_converters/external_service_converter.rb#3
class ScoutApm::LayerConverters::ExternalServiceConverter < ::ScoutApm::LayerConverters::ConverterBase
  # @return [ExternalServiceConverter] a new instance of ExternalServiceConverter
  #
  # source://scout_apm//lib/scout_apm/layer_converters/external_service_converter.rb#4
  def initialize(*_arg0); end

  # source://scout_apm//lib/scout_apm/layer_converters/external_service_converter.rb#27
  def record!; end

  # source://scout_apm//lib/scout_apm/layer_converters/external_service_converter.rb#9
  def register_hooks(walker); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/external_service_converter.rb#37
  def skip_layer?(layer); end

  private

  # source://scout_apm//lib/scout_apm/layer_converters/external_service_converter.rb#48
  def domain_name(layer); end

  # source://scout_apm//lib/scout_apm/layer_converters/external_service_converter.rb#60
  def operation_name(layer); end
end

# If we can't name the domain name, default to:
#
# source://scout_apm//lib/scout_apm/layer_converters/external_service_converter.rb#46
ScoutApm::LayerConverters::ExternalServiceConverter::DEFAULT_DOMAIN = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/layer_converters/find_layer_by_type.rb#14
class ScoutApm::LayerConverters::FindLayerByType
  # @return [FindLayerByType] a new instance of FindLayerByType
  #
  # source://scout_apm//lib/scout_apm/layer_converters/find_layer_by_type.rb#15
  def initialize(request); end

  # source://scout_apm//lib/scout_apm/layer_converters/find_layer_by_type.rb#35
  def call(layer_types); end

  # source://scout_apm//lib/scout_apm/layer_converters/find_layer_by_type.rb#23
  def controller; end

  # source://scout_apm//lib/scout_apm/layer_converters/find_layer_by_type.rb#27
  def job; end

  # source://scout_apm//lib/scout_apm/layer_converters/find_layer_by_type.rb#31
  def queue; end

  # source://scout_apm//lib/scout_apm/layer_converters/find_layer_by_type.rb#19
  def scope; end
end

# source://scout_apm//lib/scout_apm/layer_converters/histograms.rb#4
class ScoutApm::LayerConverters::Histograms < ::ScoutApm::LayerConverters::ConverterBase
  # Updates immediate and long-term histograms for both job and web requests
  #
  # source://scout_apm//lib/scout_apm/layer_converters/histograms.rb#5
  def record!; end
end

# source://scout_apm//lib/scout_apm/layer_converters/job_converter.rb#12
class ScoutApm::LayerConverters::JobConverter < ::ScoutApm::LayerConverters::ConverterBase
  # This isn't stored as a specific layer, so grabbing it doesn't use the
  # walker callbacks
  #
  # source://scout_apm//lib/scout_apm/layer_converters/job_converter.rb#63
  def add_latency_metric!; end

  # Returns the value of attribute meta_options.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/job_converter.rb#13
  def meta_options; end

  # source://scout_apm//lib/scout_apm/layer_converters/job_converter.rb#42
  def record!; end

  # source://scout_apm//lib/scout_apm/layer_converters/job_converter.rb#15
  def register_hooks(walker); end
end

# source://scout_apm//lib/scout_apm/layer_converters/metric_converter.rb#10
class ScoutApm::LayerConverters::MetricConverter < ::ScoutApm::LayerConverters::ConverterBase
  # source://scout_apm//lib/scout_apm/layer_converters/metric_converter.rb#39
  def record!; end

  # source://scout_apm//lib/scout_apm/layer_converters/metric_converter.rb#11
  def register_hooks(walker); end
end

# source://scout_apm//lib/scout_apm/layer_converters/request_queue_time_converter.rb#3
class ScoutApm::LayerConverters::RequestQueueTimeConverter < ::ScoutApm::LayerConverters::ConverterBase
  # source://scout_apm//lib/scout_apm/layer_converters/request_queue_time_converter.rb#7
  def headers; end

  # source://scout_apm//lib/scout_apm/layer_converters/request_queue_time_converter.rb#11
  def record!; end

  private

  # Looks through the possible headers with this data, and extracts the raw
  # value of the header
  # Returns nil if not found
  #
  # source://scout_apm//lib/scout_apm/layer_converters/request_queue_time_converter.rb#44
  def locate_timestamp; end

  # Returns a timestamp in fractional seconds since epoch
  #
  # source://scout_apm//lib/scout_apm/layer_converters/request_queue_time_converter.rb#57
  def parse(time_string); end
end

# source://scout_apm//lib/scout_apm/layer_converters/request_queue_time_converter.rb#5
ScoutApm::LayerConverters::RequestQueueTimeConverter::HEADERS = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#10
class ScoutApm::LayerConverters::SlowJobConverter < ::ScoutApm::LayerConverters::ConverterBase
  # Called by the set to force this to actually be created.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#29
  def call; end

  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#63
  def create_metrics; end

  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#93
  def job_layer; end

  # ScoreItemSet API #
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#25
  def name; end

  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#92
  def queue_layer; end

  # Converter API  #
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#11
  def record!; end

  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#26
  def score; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#91
  def skip_layer?(layer); end

  # source://scout_apm//lib/scout_apm/layer_converters/slow_job_converter.rb#95
  def span_trace; end
end

# source://scout_apm//lib/scout_apm/layer_converters/slow_request_converter.rb#6
class ScoutApm::LayerConverters::SlowRequestConverter < ::ScoutApm::LayerConverters::ConverterBase
  # Unconditionally attempts to convert this into a SlowTransaction object.
  # Can return nil if the request didn't have any scope_layer.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_request_converter.rb#26
  def call; end

  # Full metrics from this request. These get stored permanently in a SlowTransaction.
  # Some merging of metrics will happen here, so if a request calls the same
  # ActiveRecord or View repeatedly, it'll get merged.
  #
  # This returns a 2-element of Metric Hashes (the first element is timing metrics, the second element is allocation metrics)
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_request_converter.rb#64
  def create_metrics; end

  # ScoreItemSet API #
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_request_converter.rb#21
  def name; end

  # Converter API  #
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_request_converter.rb#7
  def record!; end

  # source://scout_apm//lib/scout_apm/layer_converters/slow_request_converter.rb#22
  def score; end

  # Also create a new style trace. This is not a good      #
  #  spot for this long term, but fixes an issue for now.   #
  #
  # source://scout_apm//lib/scout_apm/layer_converters/slow_request_converter.rb#92
  def span_trace; end
end

# source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#6
class ScoutApm::LayerConverters::TraceConverter < ::ScoutApm::LayerConverters::ConverterBase
  # Take an array of ruby backtrace lines and split it into an array of hashes like:
  # ["/Users/cschneid/.rvm/rubies/ruby-2.2.7/lib/ruby/2.2.0/irb/workspace.rb:86:in `eval'", ...]
  #    turns into:
  # [ {
  #     "file": "app/controllers/users_controller.rb",
  #     "line": 10,
  #     "function": "index"
  # },
  # ]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#142
  def backtrace_parser(lines); end

  # Unconditionally attempts to convert this into a DetailedTrace object.
  # Can return nil if the request didn't have any scope_layer or if `timeline_traces` aren't enabled.
  #
  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#27
  def call; end

  # Returns an array of span objects. Uses recursion to get all children
  # wired up w/ correct parent_ids
  #
  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#89
  def create_spans(layer, parent_id = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#179
  def limited?; end

  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#173
  def log_over_span_limit; end

  # ScoreItemSet API #
  #
  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#22
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#164
  def over_span_limit?(spans); end

  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#9
  def record!; end

  # source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#23
  def score; end
end

# To prevent huge traces from being generated, we stop collecting
# spans as we go beyond some reasonably large count.
#
# source://scout_apm//lib/scout_apm/layer_converters/trace_converter.rb#162
ScoutApm::LayerConverters::TraceConverter::MAX_SPANS = T.let(T.unsafe(nil), Integer)

# A LimitedLayer is a lossy-compression approach to fall back on once we max out
# the number of detailed layer objects we store.  See LayerChildrenSet for the
# logic on when that change over happens
#
# QUESTION: What do we do if we attempt to merge an item that has children?
#
# source://scout_apm//lib/scout_apm/limited_layer.rb#7
class ScoutApm::LimitedLayer
  # @return [LimitedLayer] a new instance of LimitedLayer
  #
  # source://scout_apm//lib/scout_apm/limited_layer.rb#10
  def initialize(type); end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#20
  def absorb(layer); end

  # Many methods don't make any sense on a limited layer. Raise errors  #
  #  aggressively for now to detect mistaken calls                      #
  #
  # source://scout_apm//lib/scout_apm/limited_layer.rb#94
  def add_child; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#110
  def annotate_layer(*_arg0); end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#61
  def annotations; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#84
  def backtrace; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#122
  def caller_array; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#118
  def capture_backtrace!; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#57
  def children; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#46
  def count; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#80
  def desc; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#106
  def desc=(*_arg0); end

  # This is the old style name. This function is used for now, but should be
  # removed, and the new type & name split should be enforced through the
  # app.
  #
  # source://scout_apm//lib/scout_apm/limited_layer.rb#53
  def legacy_metric_name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/limited_layer.rb#69
  def limited?; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#102
  def record_allocations!; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#98
  def record_stop_time!(*_arg0); end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#114
  def subscopable!; end

  # Stub out some methods with static default values  #
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/limited_layer.rb#76
  def subscopable?; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#65
  def to_s; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#38
  def total_allocations; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#30
  def total_call_time; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#42
  def total_exclusive_allocations; end

  # source://scout_apm//lib/scout_apm/limited_layer.rb#34
  def total_exclusive_time; end

  # Returns the value of attribute type.
  #
  # source://scout_apm//lib/scout_apm/limited_layer.rb#8
  def type; end
end

# source://scout_apm//lib/scout_apm/logger.rb#23
class ScoutApm::Logger
  # @return [Logger] a new instance of Logger
  #
  # source://scout_apm//lib/scout_apm/logger.rb#26
  def initialize(environment_root, opts = T.unsafe(nil)); end

  # Delegate calls to the underlying logger
  #
  # source://scout_apm//lib/scout_apm/logger.rb#37
  def debug(*args, &block); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/logger.rb#43
  def debug?; end

  # source://scout_apm//lib/scout_apm/logger.rb#40
  def error(*args, &block); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/logger.rb#46
  def error?; end

  # source://scout_apm//lib/scout_apm/logger.rb#41
  def fatal(*args, &block); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/logger.rb#47
  def fatal?; end

  # source://scout_apm//lib/scout_apm/logger.rb#38
  def info(*args, &block); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/logger.rb#44
  def info?; end

  # Returns the value of attribute log_destination.
  #
  # source://scout_apm//lib/scout_apm/logger.rb#24
  def log_destination; end

  # source://scout_apm//lib/scout_apm/logger.rb#57
  def log_file_path; end

  # source://scout_apm//lib/scout_apm/logger.rb#53
  def log_level; end

  # source://scout_apm//lib/scout_apm/logger.rb#49
  def log_level=(level); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/logger.rb#65
  def stderr?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/logger.rb#61
  def stdout?; end

  # source://scout_apm//lib/scout_apm/logger.rb#39
  def warn(*args, &block); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/logger.rb#45
  def warn?; end

  private

  # source://scout_apm//lib/scout_apm/logger.rb#96
  def build_formatter; end

  # source://scout_apm//lib/scout_apm/logger.rb#71
  def build_logger; end

  # source://scout_apm//lib/scout_apm/logger.rb#118
  def determine_log_destination; end

  # source://scout_apm//lib/scout_apm/logger.rb#104
  def log_level_from_opts(explicit = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/logger.rb#79
  def logger_class; end

  # Check if this path is ok for a log file.
  # Does it exist?
  # Is it writable?
  #
  # source://scout_apm//lib/scout_apm/logger.rb#137
  def validate_path(candidate); end
end

# source://scout_apm//lib/scout_apm/logger.rb#144
class ScoutApm::Logger::DefaultFormatter < ::Logger::Formatter
  # source://scout_apm//lib/scout_apm/logger.rb#145
  def call(severity, time, progname, msg); end
end

# since STDOUT & STDERR isn't only used for ScoutApm logging, apply a
# prefix to make it easily greppable
#
# source://scout_apm//lib/scout_apm/logger.rb#154
class ScoutApm::Logger::TaggedFormatter < ::ScoutApm::Logger::DefaultFormatter
  # source://scout_apm//lib/scout_apm/logger.rb#157
  def call(severity, time, progname, msg); end
end

# source://scout_apm//lib/scout_apm/logger.rb#155
ScoutApm::Logger::TaggedFormatter::TAG = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/agent_context.rb#244
class ScoutApm::LoggerFactory
  class << self
    # source://scout_apm//lib/scout_apm/agent_context.rb#245
    def build(config, environment); end

    # source://scout_apm//lib/scout_apm/agent_context.rb#257
    def build_minimal_logger; end
  end
end

# source://scout_apm//lib/scout_apm/metric_meta.rb#3
class ScoutApm::MetricMeta
  include ::ScoutApm::BucketNameSplitter

  # @return [MetricMeta] a new instance of MetricMeta
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#6
  def initialize(metric_name, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/metric_meta.rb#36
  def ==(o); end

  # source://scout_apm//lib/scout_apm/metric_meta.rb#64
  def as_json; end

  # source://scout_apm//lib/scout_apm/metric_meta.rb#45
  def backtrace; end

  # This should be abstracted to a true accessor ... earned it.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#41
  def backtrace=(bt); end

  # Returns the value of attribute client_id.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#15
  def client_id; end

  # Sets the attribute client_id
  #
  # @param value the value to set the attribute client_id to.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#15
  def client_id=(_arg0); end

  # Returns the value of attribute desc.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#16
  def desc; end

  # Sets the attribute desc
  #
  # @param value the value to set the attribute desc to.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#16
  def desc=(_arg0); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#56
  def eql?(o); end

  # Returns the value of attribute extra.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#16
  def extra; end

  # Sets the attribute extra
  #
  # @param value the value to set the attribute extra to.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#16
  def extra=(_arg0); end

  # source://scout_apm//lib/scout_apm/metric_meta.rb#49
  def hash; end

  # A key metric is the "core" of a request - either the Rails controller reached, or the background Job executed
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#28
  def key_metric?; end

  # Returns the value of attribute metric_id.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#13
  def metric_id; end

  # Sets the attribute metric_id
  #
  # @param value the value to set the attribute metric_id to.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#13
  def metric_id=(_arg0); end

  # Returns the value of attribute metric_name.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#13
  def metric_name; end

  # Sets the attribute metric_name
  #
  # @param value the value to set the attribute metric_name to.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#13
  def metric_name=(_arg0); end

  # source://scout_apm//lib/scout_apm/metric_meta.rb#23
  def name; end

  # Returns the value of attribute scope.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#14
  def scope; end

  # Sets the attribute scope
  #
  # @param value the value to set the attribute scope to.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#14
  def scope=(_arg0); end

  # Unsure if type or bucket is a better name.
  #
  # source://scout_apm//lib/scout_apm/metric_meta.rb#19
  def type; end

  class << self
    # @return [Boolean]
    #
    # source://scout_apm//lib/scout_apm/metric_meta.rb#32
    def key_metric?(metric_name); end
  end
end

# source://scout_apm//lib/scout_apm/metric_set.rb#2
class ScoutApm::MetricSet
  # @return [MetricSet] a new instance of MetricSet
  #
  # source://scout_apm//lib/scout_apm/metric_set.rb#11
  def initialize; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/metric_set.rb#56
  def ==(other); end

  # Absorbs a single new metric into the aggregates
  #
  # source://scout_apm//lib/scout_apm/metric_set.rb#20
  def absorb(metric); end

  # source://scout_apm//lib/scout_apm/metric_set.rb#15
  def absorb_all(metrics); end

  # Sets a combine_in_progress flag to prevent double-counting Error metrics.
  # Without it, the Errors/Request number would be increasingly off as
  # metric_sets get merged in.
  #
  # source://scout_apm//lib/scout_apm/metric_set.rb#48
  def combine!(other); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/metric_set.rb#56
  def eql?(other); end

  # Returns the value of attribute metrics.
  #
  # source://scout_apm//lib/scout_apm/metric_set.rb#9
  def metrics; end
end

# We can't aggregate a handful of things like samplers (CPU, Memory), or
# Controller, and Percentiles so pass through these metrics directly
#
# TODO: Figure out a way to not have this duplicate what's in Samplers, and also on server's ingest
#
# source://scout_apm//lib/scout_apm/metric_set.rb#7
ScoutApm::MetricSet::PASSTHROUGH_METRICS = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/metric_stats.rb#3
class ScoutApm::MetricStats
  # @return [MetricStats] a new instance of MetricStats
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#13
  def initialize(scoped = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/metric_stats.rb#53
  def as_json; end

  # Returns the value of attribute call_count.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#4
  def call_count; end

  # Sets the attribute call_count
  #
  # @param value the value to set the attribute call_count to.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#4
  def call_count=(_arg0); end

  # combines data from another MetricStats object
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#43
  def combine!(other); end

  # Returns the value of attribute latency.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#11
  def latency; end

  # Sets the attribute latency
  #
  # @param value the value to set the attribute latency to.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#11
  def latency=(_arg0); end

  # Returns the value of attribute max_call_time.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#6
  def max_call_time; end

  # Sets the attribute max_call_time
  #
  # @param value the value to set the attribute max_call_time to.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#6
  def max_call_time=(_arg0); end

  # Returns the value of attribute min_call_time.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#5
  def min_call_time; end

  # Sets the attribute min_call_time
  #
  # @param value the value to set the attribute min_call_time to.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#5
  def min_call_time=(_arg0); end

  # Returns the value of attribute queue.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#10
  def queue; end

  # Sets the attribute queue
  #
  # @param value the value to set the attribute queue to.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#10
  def queue=(_arg0); end

  # Returns the value of attribute sum_of_squares.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#9
  def sum_of_squares; end

  # Sets the attribute sum_of_squares
  #
  # @param value the value to set the attribute sum_of_squares to.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#9
  def sum_of_squares=(_arg0); end

  # Returns the value of attribute total_call_time.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#7
  def total_call_time; end

  # Sets the attribute total_call_time
  #
  # @param value the value to set the attribute total_call_time to.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#7
  def total_call_time=(_arg0); end

  # Returns the value of attribute total_exclusive_time.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#8
  def total_exclusive_time; end

  # Sets the attribute total_exclusive_time
  #
  # @param value the value to set the attribute total_exclusive_time to.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#8
  def total_exclusive_time=(_arg0); end

  # Note, that you must include exclusive_time if you wish to set
  # extra_metrics. A two argument use of this method won't do that.
  #
  # source://scout_apm//lib/scout_apm/metric_stats.rb#25
  def update!(call_time, exclusive_time = T.unsafe(nil), extra_metrics = T.unsafe(nil)); end
end

# source://scout_apm//lib/scout_apm/middleware.rb#2
class ScoutApm::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://scout_apm//lib/scout_apm/middleware.rb#5
  def initialize(app); end

  # source://scout_apm//lib/scout_apm/middleware.rb#24
  def attempt_to_start_agent; end

  # If we get a web request in, then we know we're running in some sort of app server
  #
  # source://scout_apm//lib/scout_apm/middleware.rb#15
  def call(env); end
end

# source://scout_apm//lib/scout_apm/middleware.rb#3
ScoutApm::Middleware::MAX_ATTEMPTS = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/histogram.rb#4
class ScoutApm::NumericHistogram
  # @return [NumericHistogram] a new instance of NumericHistogram
  #
  # source://scout_apm//lib/scout_apm/histogram.rb#21
  def initialize(max_bins); end

  # source://scout_apm//lib/scout_apm/histogram.rb#28
  def add(new_value); end

  # Given a value, where in this histogram does it fall?
  # Returns a float between 0 and 1
  #
  # source://scout_apm//lib/scout_apm/histogram.rb#61
  def approximate_quantile_of_value(v); end

  # source://scout_apm//lib/scout_apm/histogram.rb#105
  def as_json; end

  # Returns the value of attribute bins.
  #
  # source://scout_apm//lib/scout_apm/histogram.rb#9
  def bins; end

  # source://scout_apm//lib/scout_apm/histogram.rb#90
  def combine!(other); end

  # source://scout_apm//lib/scout_apm/histogram.rb#12
  def marshal_dump; end

  # source://scout_apm//lib/scout_apm/histogram.rb#16
  def marshal_load(array); end

  # Returns the value of attribute max_bins.
  #
  # source://scout_apm//lib/scout_apm/histogram.rb#8
  def max_bins; end

  # source://scout_apm//lib/scout_apm/histogram.rb#79
  def mean; end

  # This class should be threadsafe.
  #
  # source://scout_apm//lib/scout_apm/histogram.rb#6
  def mutex; end

  # source://scout_apm//lib/scout_apm/histogram.rb#36
  def quantile(q); end

  # Returns the value of attribute total.
  #
  # source://scout_apm//lib/scout_apm/histogram.rb#10
  def total; end

  # Sets the attribute total
  #
  # @param value the value to set the attribute total to.
  #
  # source://scout_apm//lib/scout_apm/histogram.rb#10
  def total=(_arg0); end

  private

  # If we exactly match an existing bin, add to it, otherwise create a new bin holding a count for the new value.
  #
  # source://scout_apm//lib/scout_apm/histogram.rb#119
  def create_new_bin(new_value); end

  # source://scout_apm//lib/scout_apm/histogram.rb#140
  def trim; end

  # source://scout_apm//lib/scout_apm/histogram.rb#146
  def trim_one; end
end

# source://scout_apm//lib/scout_apm/periodic_work.rb#2
class ScoutApm::PeriodicWork
  # @return [PeriodicWork] a new instance of PeriodicWork
  #
  # source://scout_apm//lib/scout_apm/periodic_work.rb#5
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/periodic_work.rb#3
  def context; end

  # Expected to be called many times over the life of the agent
  #
  # source://scout_apm//lib/scout_apm/periodic_work.rb#11
  def run; end

  private

  # XXX: Move logic into a RequestHistogramsByTime class that can keep the timeout logic in it
  #
  # source://scout_apm//lib/scout_apm/periodic_work.rb#39
  def clean_old_percentiles; end

  # source://scout_apm//lib/scout_apm/periodic_work.rb#23
  def log_autoinstrument_significant_counts; end
end

# source://scout_apm//lib/scout_apm/platform_integrations/heroku.rb#2
module ScoutApm::PlatformIntegrations; end

# source://scout_apm//lib/scout_apm/platform_integrations/cloud_foundry.rb#3
class ScoutApm::PlatformIntegrations::CloudFoundry
  # TODO: Is there a better way to get a hostname from Cloud Foundry?
  #
  # source://scout_apm//lib/scout_apm/platform_integrations/cloud_foundry.rb#18
  def hostname; end

  # TODO: Which is easier for users by defualt? STDOUT or our log/scout_apm.log file?
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/platform_integrations/cloud_foundry.rb#13
  def log_to_stdout?; end

  # source://scout_apm//lib/scout_apm/platform_integrations/cloud_foundry.rb#8
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/platform_integrations/cloud_foundry.rb#4
  def present?; end
end

# source://scout_apm//lib/scout_apm/platform_integrations/heroku.rb#3
class ScoutApm::PlatformIntegrations::Heroku
  # source://scout_apm//lib/scout_apm/platform_integrations/heroku.rb#16
  def hostname; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/platform_integrations/heroku.rb#12
  def log_to_stdout?; end

  # source://scout_apm//lib/scout_apm/platform_integrations/heroku.rb#8
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/platform_integrations/heroku.rb#4
  def present?; end
end

# source://scout_apm//lib/scout_apm/platform_integrations/server.rb#6
class ScoutApm::PlatformIntegrations::Server
  # source://scout_apm//lib/scout_apm/platform_integrations/server.rb#19
  def hostname; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/platform_integrations/server.rb#15
  def log_to_stdout?; end

  # source://scout_apm//lib/scout_apm/platform_integrations/server.rb#11
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/platform_integrations/server.rb#7
  def present?; end
end

# source://scout_apm//lib/scout_apm/rack.rb#2
module ScoutApm::Rack
  class << self
    # source://scout_apm//lib/scout_apm/rack.rb#3
    def install!; end

    # source://scout_apm//lib/scout_apm/rack.rb#8
    def transaction(endpoint_name, env); end
  end
end

# source://scout_apm//lib/scout_apm.rb#216
class ScoutApm::Railtie < ::Rails::Railtie; end

# source://scout_apm//lib/scout_apm/agent_context.rb#232
class ScoutApm::RecorderFactory
  class << self
    # source://scout_apm//lib/scout_apm/agent_context.rb#233
    def build(context); end
  end
end

# source://scout_apm//lib/scout_apm/remote/server.rb#4
module ScoutApm::Remote; end

# source://scout_apm//lib/scout_apm/remote/message.rb#3
class ScoutApm::Remote::Message
  # @return [Message] a new instance of Message
  #
  # source://scout_apm//lib/scout_apm/remote/message.rb#8
  def initialize(type, command, *args); end

  # Returns the value of attribute args.
  #
  # source://scout_apm//lib/scout_apm/remote/message.rb#6
  def args; end

  # Returns the value of attribute command.
  #
  # source://scout_apm//lib/scout_apm/remote/message.rb#5
  def command; end

  # source://scout_apm//lib/scout_apm/remote/message.rb#18
  def encode; end

  # Returns the value of attribute type.
  #
  # source://scout_apm//lib/scout_apm/remote/message.rb#4
  def type; end

  class << self
    # source://scout_apm//lib/scout_apm/remote/message.rb#14
    def decode(msg); end
  end
end

# source://scout_apm//lib/scout_apm/remote/recorder.rb#3
class ScoutApm::Remote::Recorder
  # @return [Recorder] a new instance of Recorder
  #
  # source://scout_apm//lib/scout_apm/remote/recorder.rb#8
  def initialize(remote_agent_host, remote_agent_port, logger); end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/remote/recorder.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/remote/recorder.rb#49
  def post(encoded_message); end

  # source://scout_apm//lib/scout_apm/remote/recorder.rb#23
  def record!(request); end

  # Returns the value of attribute remote_agent_host.
  #
  # source://scout_apm//lib/scout_apm/remote/recorder.rb#5
  def remote_agent_host; end

  # Returns the value of attribute remote_agent_port.
  #
  # source://scout_apm//lib/scout_apm/remote/recorder.rb#6
  def remote_agent_port; end

  # source://scout_apm//lib/scout_apm/remote/recorder.rb#14
  def start; end

  # source://scout_apm//lib/scout_apm/remote/recorder.rb#19
  def stop; end
end

# source://scout_apm//lib/scout_apm/remote/router.rb#3
class ScoutApm::Remote::Router
  # If/When we add different types, this signature should change to a hash
  # of {type => Object}, rather than building it in the initializer here.
  #
  # Keys of routes should be strings
  #
  # @return [Router] a new instance of Router
  #
  # source://scout_apm//lib/scout_apm/remote/router.rb#11
  def initialize(recorder, logger); end

  # A message is a 2 element array [:type, :command, [args]].
  # For this first creation, this should be ['record', 'record', [TrackedRequest]] (the args arg should always be an array, even w/ only 1 item)
  #
  # Where
  #   type: ['recorder']
  #   command: any function supported on that type of object
  #   args: any array of arguments
  #
  # Raises on unknown message
  #
  # Returns whatever the recipient object returns
  #
  # source://scout_apm//lib/scout_apm/remote/router.rb#30
  def handle(msg); end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/remote/router.rb#4
  def logger; end

  # Returns the value of attribute routes.
  #
  # source://scout_apm//lib/scout_apm/remote/router.rb#5
  def routes; end

  private

  # source://scout_apm//lib/scout_apm/remote/router.rb#38
  def assert_type(message); end

  # source://scout_apm//lib/scout_apm/remote/router.rb#44
  def call_route(message); end
end

# source://scout_apm//lib/scout_apm/remote/server.rb#5
class ScoutApm::Remote::Server
  # @return [Server] a new instance of Server
  #
  # source://scout_apm//lib/scout_apm/remote/server.rb#11
  def initialize(bind, port, router, logger); end

  # Returns the value of attribute bind.
  #
  # source://scout_apm//lib/scout_apm/remote/server.rb#7
  def bind; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/remote/server.rb#9
  def logger; end

  # Returns the value of attribute port.
  #
  # source://scout_apm//lib/scout_apm/remote/server.rb#8
  def port; end

  # source://scout_apm//lib/scout_apm/remote/server.rb#19
  def require_webrick; end

  # Returns the value of attribute router.
  #
  # source://scout_apm//lib/scout_apm/remote/server.rb#6
  def router; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/remote/server.rb#61
  def running?; end

  # source://scout_apm//lib/scout_apm/remote/server.rb#31
  def start; end

  # source://scout_apm//lib/scout_apm/remote/server.rb#66
  def stop; end
end

# source://scout_apm//lib/scout_apm/reporter.rb#4
class ScoutApm::Reporter
  # @return [Reporter] a new instance of Reporter
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#11
  def initialize(context, type, instant_key = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#61
  def can_report?; end

  # source://scout_apm//lib/scout_apm/reporter.rb#17
  def config; end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#8
  def context; end

  # Returns the value of attribute instant_key.
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#9
  def instant_key; end

  # source://scout_apm//lib/scout_apm/reporter.rb#21
  def logger; end

  # The fully serialized string payload to be sent
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#26
  def report(payload, headers = T.unsafe(nil)); end

  # Returns the value of attribute type.
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#7
  def type; end

  # source://scout_apm//lib/scout_apm/reporter.rb#43
  def uri(host); end

  private

  # source://scout_apm//lib/scout_apm/reporter.rb#135
  def compress_payload(payload); end

  # Headers passed up with all API requests.
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#111
  def default_http_headers; end

  # Some posts (typically ones under development) bypass the ingestion
  # pipeline and go directly to the webserver. They use direct_host instead
  # of host
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#145
  def determine_hosts; end

  # Take care of the http proxy, if specified in config.
  # Given a blank string, the proxy_uri URI instance's host/port/user/pass will be nil.
  # Net::HTTP::Proxy returns a regular Net::HTTP class if the first argument (host) is nil.
  #
  # source://scout_apm//lib/scout_apm/reporter.rb#121
  def http(url); end

  # source://scout_apm//lib/scout_apm/reporter.rb#78
  def post(uri, body, headers = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/reporter.rb#155
  def post_payload(hosts, payload, headers); end

  # source://scout_apm//lib/scout_apm/reporter.rb#90
  def request(uri, &connector); end
end

# source://scout_apm//lib/scout_apm/reporter.rb#5
ScoutApm::Reporter::VERIFY_MODE = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/reporting.rb#3
class ScoutApm::Reporting
  # @return [Reporting] a new instance of Reporting
  #
  # source://scout_apm//lib/scout_apm/reporting.rb#6
  def initialize(context); end

  # Before reporting, lookup metric_id for each MetricMeta. This speeds up
  # reporting on the server-side.
  #
  # source://scout_apm//lib/scout_apm/reporting.rb#136
  def add_metric_ids(metrics); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/reporting.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/reporting.rb#79
  def deliver_period(reporting_period, metadata); end

  # TODO: Move this into PayloadSerializer?
  # XXX: Remove non-json report format entirely
  #
  # source://scout_apm//lib/scout_apm/reporting.rb#126
  def headers; end

  # source://scout_apm//lib/scout_apm/reporting.rb#101
  def log_deliver(metrics, slow_transactions, metadata, jobs_traces, histograms); end

  # source://scout_apm//lib/scout_apm/reporting.rb#10
  def logger; end

  # source://scout_apm//lib/scout_apm/reporting.rb#68
  def metadata(reporting_period); end

  # The data moves through a treadmill of reporting, coordinating several Rails processes by using an external file.
  # * During the minute it is being recorded by the instruments, it gets
  #   recorded into the ram of each process (in the Store class).
  # * The minute after, each process writes its own metrics to a shared LayawayFile
  # * The minute after that, the first process to wake up pushes the combined
  #   data to the server, and wipes it. Next processes don't have anything to do.
  #
  # At any given point, there is data in each of those steps, moving its way through the process
  #
  # source://scout_apm//lib/scout_apm/reporting.rb#26
  def process_metrics; end

  # In a running app, one process will get the period ready for delivery, the others will see 0.
  #
  # source://scout_apm//lib/scout_apm/reporting.rb#40
  def report_to_server; end

  # source://scout_apm//lib/scout_apm/reporting.rb#14
  def reporter; end
end

# source://scout_apm//lib/scout_apm/request_histograms.rb#2
class ScoutApm::RequestHistograms
  # @return [RequestHistograms] a new instance of RequestHistograms
  #
  # source://scout_apm//lib/scout_apm/request_histograms.rb#16
  def initialize(histogram_size = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/request_histograms.rb#33
  def add(item, value); end

  # source://scout_apm//lib/scout_apm/request_histograms.rb#37
  def approximate_quantile_of_value(item, value); end

  # source://scout_apm//lib/scout_apm/request_histograms.rb#25
  def as_json; end

  # source://scout_apm//lib/scout_apm/request_histograms.rb#21
  def each_name; end

  # Returns the value of attribute histogram_size.
  #
  # source://scout_apm//lib/scout_apm/request_histograms.rb#14
  def histogram_size; end

  # source://scout_apm//lib/scout_apm/request_histograms.rb#54
  def initialize_histograms_hash; end

  # source://scout_apm//lib/scout_apm/request_histograms.rb#41
  def quantile(item, q); end

  # source://scout_apm//lib/scout_apm/request_histograms.rb#50
  def raw(item); end

  # Wipes all histograms, setting them back to empty
  #
  # source://scout_apm//lib/scout_apm/request_histograms.rb#46
  def reset_all!; end

  private

  # Private Accessor:
  # A hash of Endpoint Name to an approximate histogram
  #
  # Each time a new request is requested to see if it's slow or not, we
  # should insert it into the histogram, and get the approximate percentile
  # of that time
  #
  # source://scout_apm//lib/scout_apm/request_histograms.rb#11
  def histograms; end
end

# source://scout_apm//lib/scout_apm/request_histograms.rb#3
ScoutApm::RequestHistograms::DEFAULT_HISTOGRAM_SIZE = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/request_manager.rb#5
class ScoutApm::RequestManager
  class << self
    # Create a new TrackedRequest object for this thread
    # XXX: Figure out who is in charge of creating a `FakeStore` - previously was here
    #
    # source://scout_apm//lib/scout_apm/request_manager.rb#23
    def create; end

    # Get the current Thread local, and detecting, and not returning a stale request
    #
    # source://scout_apm//lib/scout_apm/request_manager.rb#11
    def find; end

    # source://scout_apm//lib/scout_apm/request_manager.rb#6
    def lookup; end
  end
end

# source://scout_apm//lib/scout_apm/scored_item_set.rb#8
class ScoutApm::ScoredItemSet
  include ::Enumerable

  # @return [ScoredItemSet] a new instance of ScoredItemSet
  #
  # source://scout_apm//lib/scout_apm/scored_item_set.rb#20
  def initialize(max_size = T.unsafe(nil)); end

  # This function is a large if statement, with a few branches. See inline comments for each branch.
  #
  # source://scout_apm//lib/scout_apm/scored_item_set.rb#32
  def <<(new_item); end

  # Equal to another set only if exactly the same set of items is inside
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/scored_item_set.rb#67
  def ==(other); end

  # source://scout_apm//lib/scout_apm/scored_item_set.rb#25
  def each; end

  # Equal to another set only if exactly the same set of items is inside
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/scored_item_set.rb#67
  def eql?(other); end

  # Returns the value of attribute items.
  #
  # source://scout_apm//lib/scout_apm/scored_item_set.rb#18
  def items; end

  # Returns the value of attribute max_size.
  #
  # source://scout_apm//lib/scout_apm/scored_item_set.rb#17
  def max_size; end

  private

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/scored_item_set.rb#75
  def full?; end

  # source://scout_apm//lib/scout_apm/scored_item_set.rb#79
  def store!(new_item); end
end

# A number larger than any score we will actually get.
#
# source://scout_apm//lib/scout_apm/scored_item_set.rb#12
ScoutApm::ScoredItemSet::ARBITRARILY_LARGE = T.let(T.unsafe(nil), Integer)

# Without otherwise saying, default the size to this
#
# source://scout_apm//lib/scout_apm/scored_item_set.rb#15
ScoutApm::ScoredItemSet::DEFAULT_MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/serializers/payload_serializer.rb#3
module ScoutApm::Serializers; end

# source://scout_apm//lib/scout_apm/serializers/app_server_load_serializer.rb#5
class ScoutApm::Serializers::AppServerLoadSerializer
  class << self
    # source://scout_apm//lib/scout_apm/serializers/app_server_load_serializer.rb#14
    def deserialize(data); end

    # source://scout_apm//lib/scout_apm/serializers/app_server_load_serializer.rb#6
    def serialize(data); end
  end
end

# source://scout_apm//lib/scout_apm/serializers/db_query_serializer_to_json.rb#3
class ScoutApm::Serializers::DbQuerySerializerToJson
  # @return [DbQuerySerializerToJson] a new instance of DbQuerySerializerToJson
  #
  # source://scout_apm//lib/scout_apm/serializers/db_query_serializer_to_json.rb#6
  def initialize(db_query_metrics); end

  # source://scout_apm//lib/scout_apm/serializers/db_query_serializer_to_json.rb#10
  def as_json; end

  # Returns the value of attribute db_query_metrics.
  #
  # source://scout_apm//lib/scout_apm/serializers/db_query_serializer_to_json.rb#4
  def db_query_metrics; end
end

# source://scout_apm//lib/scout_apm/serializers/directive_serializer.rb#5
class ScoutApm::Serializers::DirectiveSerializer
  class << self
    # source://scout_apm//lib/scout_apm/serializers/directive_serializer.rb#14
    def deserialize(data); end

    # source://scout_apm//lib/scout_apm/serializers/directive_serializer.rb#6
    def serialize(data); end
  end
end

# source://scout_apm//lib/scout_apm/serializers/external_service_serializer_to_json.rb#3
class ScoutApm::Serializers::ExternalServiceSerializerToJson
  # @return [ExternalServiceSerializerToJson] a new instance of ExternalServiceSerializerToJson
  #
  # source://scout_apm//lib/scout_apm/serializers/external_service_serializer_to_json.rb#6
  def initialize(external_service_metrics); end

  # source://scout_apm//lib/scout_apm/serializers/external_service_serializer_to_json.rb#10
  def as_json; end

  # Returns the value of attribute external_service_metrics.
  #
  # source://scout_apm//lib/scout_apm/serializers/external_service_serializer_to_json.rb#4
  def external_service_metrics; end
end

# source://scout_apm//lib/scout_apm/serializers/histograms_serializer_to_json.rb#4
class ScoutApm::Serializers::HistogramsSerializerToJson
  # @return [HistogramsSerializerToJson] a new instance of HistogramsSerializerToJson
  #
  # source://scout_apm//lib/scout_apm/serializers/histograms_serializer_to_json.rb#7
  def initialize(histograms); end

  # source://scout_apm//lib/scout_apm/serializers/histograms_serializer_to_json.rb#11
  def as_json; end

  # Returns the value of attribute histograms.
  #
  # source://scout_apm//lib/scout_apm/serializers/histograms_serializer_to_json.rb#5
  def histograms; end
end

# source://scout_apm//lib/scout_apm/serializers/jobs_serializer_to_json.rb#3
class ScoutApm::Serializers::JobsSerializerToJson
  # Jobs is a pre-deduped/combined set of job records.
  #
  # @return [JobsSerializerToJson] a new instance of JobsSerializerToJson
  #
  # source://scout_apm//lib/scout_apm/serializers/jobs_serializer_to_json.rb#7
  def initialize(jobs); end

  # An array of job records
  #
  # source://scout_apm//lib/scout_apm/serializers/jobs_serializer_to_json.rb#12
  def as_json; end

  # Returns the value of attribute jobs.
  #
  # source://scout_apm//lib/scout_apm/serializers/jobs_serializer_to_json.rb#4
  def jobs; end
end

# source://scout_apm//lib/scout_apm/serializers/metrics_to_json_serializer.rb#3
class ScoutApm::Serializers::MetricsToJsonSerializer
  # A hash of meta => stat pairs
  #
  # @return [MetricsToJsonSerializer] a new instance of MetricsToJsonSerializer
  #
  # source://scout_apm//lib/scout_apm/serializers/metrics_to_json_serializer.rb#7
  def initialize(metrics); end

  # source://scout_apm//lib/scout_apm/serializers/metrics_to_json_serializer.rb#11
  def as_json; end

  # Children metrics is a hash of meta=>stat pairs. Leave empty for no children.
  # Supports only a single-level nesting, until we have redone metric
  # classes, instead of Meta and Stats
  #
  # source://scout_apm//lib/scout_apm/serializers/metrics_to_json_serializer.rb#22
  def metric_as_json(meta, stat, child_metrics = T.unsafe(nil)); end

  # Returns the value of attribute metrics.
  #
  # source://scout_apm//lib/scout_apm/serializers/metrics_to_json_serializer.rb#4
  def metrics; end

  # source://scout_apm//lib/scout_apm/serializers/metrics_to_json_serializer.rb#48
  def transform_child_metrics(metrics); end
end

# source://scout_apm//lib/scout_apm/serializers/payload_serializer.rb#4
class ScoutApm::Serializers::PayloadSerializer
  class << self
    # source://scout_apm//lib/scout_apm/serializers/payload_serializer.rb#30
    def deserialize(data); end

    # source://scout_apm//lib/scout_apm/serializers/payload_serializer.rb#5
    def serialize(metadata, metrics, slow_transactions, jobs, slow_jobs, histograms, db_query_metrics, external_service_metrics, traces); end
  end
end

# source://scout_apm//lib/scout_apm/serializers/payload_serializer_to_json.rb#3
module ScoutApm::Serializers::PayloadSerializerToJson
  class << self
    # source://scout_apm//lib/scout_apm/serializers/payload_serializer_to_json.rb#63
    def escape(string); end

    # source://scout_apm//lib/scout_apm/serializers/payload_serializer_to_json.rb#69
    def format_by_type(formatee); end

    # source://scout_apm//lib/scout_apm/serializers/payload_serializer_to_json.rb#41
    def jsonify_hash(hash); end

    # takes just one slow transaction
    #
    # source://scout_apm//lib/scout_apm/serializers/payload_serializer_to_json.rb#37
    def rearrange_slow_transaction(slow_t); end

    # For the old style of metric serializing.
    #
    # source://scout_apm//lib/scout_apm/serializers/payload_serializer_to_json.rb#25
    def rearrange_the_metrics(metrics); end

    # takes an array of slow transactions
    #
    # source://scout_apm//lib/scout_apm/serializers/payload_serializer_to_json.rb#32
    def rearrange_the_slow_transactions(slow_transactions); end

    # source://scout_apm//lib/scout_apm/serializers/payload_serializer_to_json.rb#5
    def serialize(metadata, metrics, slow_transactions, jobs, slow_jobs, histograms, db_query_metrics, external_service_metrics, traces); end
  end
end

# source://scout_apm//lib/scout_apm/serializers/slow_jobs_serializer_to_json.rb#3
class ScoutApm::Serializers::SlowJobsSerializerToJson
  # Jobs is a series of slow job records
  #
  # @return [SlowJobsSerializerToJson] a new instance of SlowJobsSerializerToJson
  #
  # source://scout_apm//lib/scout_apm/serializers/slow_jobs_serializer_to_json.rb#7
  def initialize(jobs); end

  # An array of job records
  #
  # source://scout_apm//lib/scout_apm/serializers/slow_jobs_serializer_to_json.rb#12
  def as_json; end

  # Returns the value of attribute jobs.
  #
  # source://scout_apm//lib/scout_apm/serializers/slow_jobs_serializer_to_json.rb#4
  def jobs; end
end

# source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#2
module ScoutApm::ServerIntegrations; end

# source://scout_apm//lib/scout_apm/server_integrations/null.rb#6
class ScoutApm::ServerIntegrations::Null
  # @return [Null] a new instance of Null
  #
  # source://scout_apm//lib/scout_apm/server_integrations/null.rb#9
  def initialize(logger); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/null.rb#25
  def forking?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/null.rb#29
  def found?; end

  # source://scout_apm//lib/scout_apm/server_integrations/null.rb#21
  def install; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/server_integrations/null.rb#7
  def logger; end

  # source://scout_apm//lib/scout_apm/server_integrations/null.rb#13
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/null.rb#17
  def present?; end
end

# source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#3
class ScoutApm::ServerIntegrations::Passenger
  # @return [Passenger] a new instance of Passenger
  #
  # source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#6
  def initialize(logger); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#14
  def forking?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#36
  def found?; end

  # source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#20
  def install; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#10
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/passenger.rb#16
  def present?; end
end

# source://scout_apm//lib/scout_apm/server_integrations/puma.rb#3
class ScoutApm::ServerIntegrations::Puma
  # @return [Puma] a new instance of Puma
  #
  # source://scout_apm//lib/scout_apm/server_integrations/puma.rb#6
  def initialize(logger); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/puma.rb#14
  def forking?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/puma.rb#38
  def found?; end

  # source://scout_apm//lib/scout_apm/server_integrations/puma.rb#26
  def install; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/server_integrations/puma.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/server_integrations/puma.rb#10
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/puma.rb#22
  def present?; end
end

# source://scout_apm//lib/scout_apm/server_integrations/rainbows.rb#3
class ScoutApm::ServerIntegrations::Rainbows
  # @return [Rainbows] a new instance of Rainbows
  #
  # source://scout_apm//lib/scout_apm/server_integrations/rainbows.rb#6
  def initialize(logger); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/rainbows.rb#14
  def forking?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/rainbows.rb#35
  def found?; end

  # source://scout_apm//lib/scout_apm/server_integrations/rainbows.rb#23
  def install; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/server_integrations/rainbows.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/server_integrations/rainbows.rb#10
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/rainbows.rb#16
  def present?; end
end

# source://scout_apm//lib/scout_apm/server_integrations/thin.rb#3
class ScoutApm::ServerIntegrations::Thin
  # @return [Thin] a new instance of Thin
  #
  # source://scout_apm//lib/scout_apm/server_integrations/thin.rb#6
  def initialize(logger); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/thin.rb#14
  def forking?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/thin.rb#39
  def found?; end

  # TODO: What does it mean to install on a non-forking env?
  #
  # source://scout_apm//lib/scout_apm/server_integrations/thin.rb#36
  def install; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/server_integrations/thin.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/server_integrations/thin.rb#10
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/thin.rb#16
  def present?; end
end

# source://scout_apm//lib/scout_apm/server_integrations/unicorn.rb#3
class ScoutApm::ServerIntegrations::Unicorn
  # @return [Unicorn] a new instance of Unicorn
  #
  # source://scout_apm//lib/scout_apm/server_integrations/unicorn.rb#6
  def initialize(logger); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/unicorn.rb#14
  def forking?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/unicorn.rb#57
  def found?; end

  # source://scout_apm//lib/scout_apm/server_integrations/unicorn.rb#46
  def install; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/server_integrations/unicorn.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/server_integrations/unicorn.rb#10
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/unicorn.rb#21
  def present?; end
end

# source://scout_apm//lib/scout_apm/server_integrations/webrick.rb#3
class ScoutApm::ServerIntegrations::Webrick
  # @return [Webrick] a new instance of Webrick
  #
  # source://scout_apm//lib/scout_apm/server_integrations/webrick.rb#6
  def initialize(logger); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/webrick.rb#14
  def forking?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/webrick.rb#24
  def found?; end

  # TODO: What does it mean to install on a non-forking env?
  #
  # source://scout_apm//lib/scout_apm/server_integrations/webrick.rb#21
  def install; end

  # Returns the value of attribute logger.
  #
  # source://scout_apm//lib/scout_apm/server_integrations/webrick.rb#4
  def logger; end

  # source://scout_apm//lib/scout_apm/server_integrations/webrick.rb#10
  def name; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/server_integrations/webrick.rb#16
  def present?; end
end

# source://scout_apm//lib/scout_apm/slow_job_record.rb#2
class ScoutApm::SlowJobRecord
  # @return [SlowJobRecord] a new instance of SlowJobRecord
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#28
  def initialize(agent_context, queue_name, job_name, time, total_time, exclusive_time, context, metrics, allocation_metrics, mem_delta, allocations, score, truncated_metrics, span_trace); end

  # Returns the value of attribute allocation_metrics.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#17
  def allocation_metrics; end

  # Returns the value of attribute allocations.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#19
  def allocations; end

  # Scorable interface
  #
  # Needed so we can merge ScoredItemSet instances
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#58
  def call; end

  # What else interesting did we learn?
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#10
  def context; end

  # Returns the value of attribute exclusive_time.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#13
  def exclusive_time; end

  # Returns the value of attribute git_sha.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#23
  def git_sha; end

  # Returns the value of attribute hostname.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#20
  def hostname; end

  # Returns the value of attribute job_name.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#4
  def job_name; end

  # Returns the value of attribute mem_delta.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#18
  def mem_delta; end

  # source://scout_apm//lib/scout_apm/slow_job_record.rb#50
  def metric_name; end

  # Returns the value of attribute metrics.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#16
  def metrics; end

  # source://scout_apm//lib/scout_apm/slow_job_record.rb#62
  def name; end

  # Returns the value of attribute queue_name.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#3
  def queue_name; end

  # Returns the value of attribute score.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#66
  def score; end

  # Returns the value of attribute seconds_since_startup.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#21
  def seconds_since_startup; end

  # Returns the value of attribute span_trace.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#26
  def span_trace; end

  # When did this job occur
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#7
  def time; end

  # Returns the value of attribute total_time.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#12
  def total_call_time; end

  # Returns the value of attribute total_time.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#12
  def total_time; end

  # Returns the value of attribute truncated_metrics.
  #
  # source://scout_apm//lib/scout_apm/slow_job_record.rb#24
  def truncated_metrics; end
end

# Note that this is semi-internal API. You should not need this, and if you do
# we're here to help at support@scoutapm.com. TrackedRequest doesn't change
# often, but we can't promise a perfectly stable API for it either.
#
# source://scout_apm//lib/scout_apm/slow_policy/policy.rb#4
module ScoutApm::SlowPolicy; end

# source://scout_apm//lib/scout_apm/slow_policy/age_policy.rb#5
class ScoutApm::SlowPolicy::AgePolicy < ::ScoutApm::SlowPolicy::Policy
  # @return [AgePolicy] a new instance of AgePolicy
  #
  # source://scout_apm//lib/scout_apm/slow_policy/age_policy.rb#15
  def initialize(context); end

  # source://scout_apm//lib/scout_apm/slow_policy/age_policy.rb#22
  def call(request); end

  # A hash of Endpoint Name to the last time we stored a slow transaction for it.
  #
  # Defaults to a start time that is pretty close to application boot time.
  # So the "age" of an endpoint we've never seen is the time the application
  # has been running.
  #
  # source://scout_apm//lib/scout_apm/slow_policy/age_policy.rb#13
  def last_seen; end

  # source://scout_apm//lib/scout_apm/slow_policy/age_policy.rb#29
  def stored!(request); end
end

# For each minute we haven't seen an endpoint
#
# source://scout_apm//lib/scout_apm/slow_policy/age_policy.rb#6
ScoutApm::SlowPolicy::AgePolicy::POINT_MULTIPLIER_AGE = T.let(T.unsafe(nil), Float)

# source://scout_apm//lib/scout_apm/slow_policy/percent_policy.rb#6
class ScoutApm::SlowPolicy::PercentPolicy < ::ScoutApm::SlowPolicy::Policy
  # Of the total time spent handling endpoints in this app, if this endpoint
  # is a higher percent, it should get more points.
  #
  # A: 20 calls @ 100ms each => 2 seconds of total time
  # B: 10 calls @ 100ms each => 1 second of total time
  #
  # Then A is 66% of the total call time
  #
  # source://scout_apm//lib/scout_apm/slow_policy/percent_policy.rb#16
  def call(request); end
end

# Points for an endpoint's who's throughput * response time is a large % of
# overall time spent processing requests
#
# source://scout_apm//lib/scout_apm/slow_policy/percent_policy.rb#7
ScoutApm::SlowPolicy::PercentPolicy::POINT_MULTIPLIER_PERCENT_TIME = T.let(T.unsafe(nil), Float)

# source://scout_apm//lib/scout_apm/slow_policy/percentile_policy.rb#4
class ScoutApm::SlowPolicy::PercentilePolicy < ::ScoutApm::SlowPolicy::Policy
  # source://scout_apm//lib/scout_apm/slow_policy/percentile_policy.rb#5
  def call(request); end
end

# source://scout_apm//lib/scout_apm/slow_policy/policy.rb#5
class ScoutApm::SlowPolicy::Policy
  # @return [Policy] a new instance of Policy
  #
  # source://scout_apm//lib/scout_apm/slow_policy/policy.rb#8
  def initialize(context); end

  # @raise [NotImplementedError]
  #
  # source://scout_apm//lib/scout_apm/slow_policy/policy.rb#12
  def call(request); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/slow_policy/policy.rb#6
  def context; end

  # Override in subclasses to execute some behavior if the request gets a
  # slot in the ScoredItemSet. Defaults to no-op
  #
  # source://scout_apm//lib/scout_apm/slow_policy/policy.rb#18
  def stored!(request); end
end

# source://scout_apm//lib/scout_apm/slow_policy/speed_policy.rb#5
class ScoutApm::SlowPolicy::SpeedPolicy < ::ScoutApm::SlowPolicy::Policy
  # Time in seconds
  # Logarithm keeps huge times from swamping the other metrics.
  # 1+ is necessary to keep the log function in positive territory.
  #
  # source://scout_apm//lib/scout_apm/slow_policy/speed_policy.rb#11
  def call(request); end
end

# Adjust speed points. See the function
#
# source://scout_apm//lib/scout_apm/slow_policy/speed_policy.rb#6
ScoutApm::SlowPolicy::SpeedPolicy::POINT_MULTIPLIER_SPEED = T.let(T.unsafe(nil), Float)

# source://scout_apm//lib/scout_apm/slow_request_policy.rb#5
class ScoutApm::SlowRequestPolicy
  # @return [SlowRequestPolicy] a new instance of SlowRequestPolicy
  #
  # source://scout_apm//lib/scout_apm/slow_request_policy.rb#10
  def initialize(context); end

  # policy is an object that behaves like a policy (responds to .call(req) for the score, and .store!(req))
  #
  # source://scout_apm//lib/scout_apm/slow_request_policy.rb#23
  def add(policy); end

  # source://scout_apm//lib/scout_apm/slow_request_policy.rb#15
  def add_default_policies; end

  # The AgentContext we're running in
  #
  # source://scout_apm//lib/scout_apm/slow_request_policy.rb#7
  def context; end

  # Returns the value of attribute policies.
  #
  # source://scout_apm//lib/scout_apm/slow_request_policy.rb#8
  def policies; end

  # Determine if this request trace should be fully analyzed by scoring it
  # across several metrics, and then determining if that's good enough to
  # make it into this minute's payload.
  #
  # Due to the combining nature of the agent & layaway file, there's no
  # guarantee that a high scoring local champion will still be a winner when
  # they go up to "regionals" and are compared against the other processes
  # running on a node.
  #
  # source://scout_apm//lib/scout_apm/slow_request_policy.rb#39
  def score(request); end

  # source://scout_apm//lib/scout_apm/slow_request_policy.rb#48
  def stored!(request); end
end

# source://scout_apm//lib/scout_apm/slow_transaction.rb#2
class ScoutApm::SlowTransaction
  include ::ScoutApm::BucketNameSplitter

  # @return [SlowTransaction] a new instance of SlowTransaction
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#23
  def initialize(agent_context, uri, metric_name, total_call_time, metrics, allocation_metrics, context, time, raw_stackprof, mem_delta, allocations, score, truncated_metrics, span_trace); end

  # Returns the value of attribute allocation_metrics.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#8
  def allocation_metrics; end

  # Returns the value of attribute allocations.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#15
  def allocations; end

  # source://scout_apm//lib/scout_apm/slow_transaction.rb#54
  def as_json; end

  # Scorable interface
  #
  # Needed so we can merge ScoredItemSet instances
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#79
  def call; end

  # Used to remove metrics when the payload will be too large.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#45
  def clear_metrics!; end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#11
  def context; end

  # source://scout_apm//lib/scout_apm/slow_transaction.rb#71
  def context_hash; end

  # hack - we need to reset these server side.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#19
  def git_sha; end

  # hack - we need to reset these server side.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#19
  def git_sha=(_arg0); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#50
  def has_metrics?; end

  # hack - we need to reset these server side.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#17
  def hostname; end

  # hack - we need to reset these server side.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#17
  def hostname=(_arg0); end

  # Returns the value of attribute mem_delta.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#14
  def mem_delta; end

  # Returns the value of attribute meta.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#9
  def meta; end

  # Returns the value of attribute metric_name.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#5
  def metric_name; end

  # Returns the value of attribute metrics.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#7
  def metrics; end

  # source://scout_apm//lib/scout_apm/slow_transaction.rb#83
  def name; end

  # Returns the value of attribute prof.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#13
  def prof; end

  # source://scout_apm//lib/scout_apm/slow_transaction.rb#87
  def score; end

  # hack - we need to reset these server side.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#18
  def seconds_since_startup; end

  # hack - we need to reset these server side.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#18
  def seconds_since_startup=(_arg0); end

  # Returns the value of attribute span_trace.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#16
  def span_trace; end

  # Returns the value of attribute time.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#12
  def time; end

  # Returns the value of attribute total_call_time.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#6
  def total_call_time; end

  # True/False that says if we had to truncate the metrics of this trace
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#21
  def truncated_metrics; end

  # Returns the value of attribute uri.
  #
  # source://scout_apm//lib/scout_apm/slow_transaction.rb#10
  def uri; end
end

# source://scout_apm//lib/scout_apm/instruments/active_record.rb#4
class ScoutApm::SqlList
  # @return [SqlList] a new instance of SqlList
  #
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#7
  def initialize(sql = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#15
  def <<(sql); end

  # All of this one, then all of the other.
  #
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#27
  def merge(other); end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#19
  def push(sql); end

  # Returns the value of attribute sqls.
  #
  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#5
  def sqls; end

  # source://scout_apm//lib/scout_apm/instruments/active_record.rb#31
  def to_s; end
end

# source://scout_apm//lib/scout_apm/stack_item.rb#2
class ScoutApm::StackItem
  # @return [StackItem] a new instance of StackItem
  #
  # source://scout_apm//lib/scout_apm/stack_item.rb#6
  def initialize(metric_name); end

  # source://scout_apm//lib/scout_apm/stack_item.rb#12
  def ==(o); end

  # Returns the value of attribute children_time.
  #
  # source://scout_apm//lib/scout_apm/stack_item.rb#3
  def children_time; end

  # Sets the attribute children_time
  #
  # @param value the value to set the attribute children_time to.
  #
  # source://scout_apm//lib/scout_apm/stack_item.rb#3
  def children_time=(_arg0); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/stack_item.rb#16
  def eql?(o); end

  # Returns the value of attribute metric_name.
  #
  # source://scout_apm//lib/scout_apm/stack_item.rb#4
  def metric_name; end

  # Returns the value of attribute start_time.
  #
  # source://scout_apm//lib/scout_apm/stack_item.rb#4
  def start_time; end
end

# source://scout_apm//lib/scout_apm/store.rb#5
class ScoutApm::Store
  # @return [Store] a new instance of Store
  #
  # source://scout_apm//lib/scout_apm/store.rb#6
  def initialize(context); end

  # Sampler support
  #
  # source://scout_apm//lib/scout_apm/store.rb#127
  def add_sampler(sampler_klass); end

  # source://scout_apm//lib/scout_apm/store.rb#15
  def current_timestamp; end

  # For each tick (minute), be sure we have a reporting period, and that samplers are run for it.
  #
  # source://scout_apm//lib/scout_apm/store.rb#109
  def tick!; end

  # Save newly collected metrics
  #
  # source://scout_apm//lib/scout_apm/store.rb#34
  def track!(metrics, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/store.rb#48
  def track_db_query_metrics!(db_query_metric_set, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/store.rb#55
  def track_external_service_metrics!(external_service_metric_set, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/store.rb#41
  def track_histograms!(histograms, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/store.rb#77
  def track_job!(job); end

  # source://scout_apm//lib/scout_apm/store.rb#62
  def track_one!(type, name, value, options = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/store.rb#84
  def track_slow_job!(job); end

  # Save a new slow transaction
  #
  # source://scout_apm//lib/scout_apm/store.rb#70
  def track_slow_transaction!(slow_transaction); end

  # Take each completed reporting_period, and write it to the layaway passed
  #
  # force - a boolean argument that forces this function to write
  # current-minute metrics.  Useful when we are shutting down the agent
  # during a restart.
  #
  # source://scout_apm//lib/scout_apm/store.rb#96
  def write_to_layaway(layaway, force = T.unsafe(nil)); end

  private

  # source://scout_apm//lib/scout_apm/store.rb#131
  def collect_samplers(rp); end

  # source://scout_apm//lib/scout_apm/store.rb#19
  def current_period; end

  # source://scout_apm//lib/scout_apm/store.rb#24
  def find_period(timestamp = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/store.rb#143
  def logger; end

  # source://scout_apm//lib/scout_apm/store.rb#114
  def write_reporting_period(layaway, time, rp); end
end

# One period of Storage. Typically 1 minute
#
# source://scout_apm//lib/scout_apm/store.rb#198
class ScoutApm::StoreReportingPeriod
  # @return [StoreReportingPeriod] a new instance of StoreReportingPeriod
  #
  # source://scout_apm//lib/scout_apm/store.rb#218
  def initialize(timestamp, context); end

  # For absorbing an array of metric {Meta => Stat} records
  #
  # source://scout_apm//lib/scout_apm/store.rb#257
  def absorb_metrics!(metrics); end

  # Returns the value of attribute db_query_metric_set.
  #
  # source://scout_apm//lib/scout_apm/store.rb#214
  def db_query_metric_set; end

  # source://scout_apm//lib/scout_apm/store.rb#341
  def db_query_metrics_payload; end

  # Returns the value of attribute external_service_metric_set.
  #
  # source://scout_apm//lib/scout_apm/store.rb#216
  def external_service_metric_set; end

  # source://scout_apm//lib/scout_apm/store.rb#345
  def external_service_metrics_payload; end

  # An Array of HistogramsReport
  #
  # source://scout_apm//lib/scout_apm/store.rb#206
  def histograms; end

  # A ScoredItemSet holding the "best" traces for the period
  #
  # source://scout_apm//lib/scout_apm/store.rb#203
  def job_traces; end

  # source://scout_apm//lib/scout_apm/store.rb#333
  def jobs; end

  # Merges another StoreReportingPeriod into this one
  #
  # source://scout_apm//lib/scout_apm/store.rb#240
  def merge(other); end

  # source://scout_apm//lib/scout_apm/store.rb#269
  def merge_db_query_metrics!(other_metric_set); end

  # source://scout_apm//lib/scout_apm/store.rb#274
  def merge_external_service_metrics!(other_metric_set); end

  # source://scout_apm//lib/scout_apm/store.rb#311
  def merge_histograms!(new_histograms); end

  # source://scout_apm//lib/scout_apm/store.rb#291
  def merge_jobs!(jobs); end

  # For merging when you have another metric_set object
  # Makes sure that you don't duplicate error count records
  #
  # source://scout_apm//lib/scout_apm/store.rb#264
  def merge_metrics!(other_metric_set); end

  # source://scout_apm//lib/scout_apm/store.rb#303
  def merge_slow_jobs!(new_jobs); end

  # source://scout_apm//lib/scout_apm/store.rb#283
  def merge_slow_transactions!(new_transactions); end

  # Returns the value of attribute metric_set.
  #
  # source://scout_apm//lib/scout_apm/store.rb#212
  def metric_set; end

  # Retrieve Metrics for reporting
  #
  # source://scout_apm//lib/scout_apm/store.rb#325
  def metrics_payload; end

  # Debug Helpers
  #
  # source://scout_apm//lib/scout_apm/store.rb#353
  def request_count; end

  # A ScoredItemSet holding the "best" traces for the period
  #
  # source://scout_apm//lib/scout_apm/store.rb#200
  def request_traces; end

  # source://scout_apm//lib/scout_apm/store.rb#337
  def slow_jobs_payload; end

  # source://scout_apm//lib/scout_apm/store.rb#329
  def slow_transactions_payload; end

  # A StoreReportingPeriodTimestamp representing the time that this
  # collection of metrics is for
  #
  # source://scout_apm//lib/scout_apm/store.rb#210
  def timestamp; end

  private

  # source://scout_apm//lib/scout_apm/store.rb#234
  def logger; end
end

# A timestamp, normalized to the beginning of a minute. Used as a hash key to
# bucket metrics into per-minute groups
#
# source://scout_apm//lib/scout_apm/store.rb#151
class ScoutApm::StoreReportingPeriodTimestamp
  # @return [StoreReportingPeriodTimestamp] a new instance of StoreReportingPeriodTimestamp
  #
  # source://scout_apm//lib/scout_apm/store.rb#154
  def initialize(time = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/store.rb#184
  def ==(o); end

  # source://scout_apm//lib/scout_apm/store.rb#192
  def age_in_seconds; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/store.rb#180
  def eql?(o); end

  # source://scout_apm//lib/scout_apm/store.rb#188
  def hash; end

  # source://scout_apm//lib/scout_apm/store.rb#168
  def strftime(pattern = T.unsafe(nil)); end

  # Returns the value of attribute timestamp.
  #
  # source://scout_apm//lib/scout_apm/store.rb#152
  def timestamp; end

  # source://scout_apm//lib/scout_apm/store.rb#164
  def to_s; end

  # source://scout_apm//lib/scout_apm/store.rb#176
  def to_time; end

  class << self
    # source://scout_apm//lib/scout_apm/store.rb#159
    def minutes_ago(min, base_time = T.unsafe(nil)); end
  end
end

# source://scout_apm//lib/scout_apm/synchronous_recorder.rb#6
class ScoutApm::SynchronousRecorder
  # @return [SynchronousRecorder] a new instance of SynchronousRecorder
  #
  # source://scout_apm//lib/scout_apm/synchronous_recorder.rb#9
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/synchronous_recorder.rb#7
  def context; end

  # source://scout_apm//lib/scout_apm/synchronous_recorder.rb#13
  def logger; end

  # source://scout_apm//lib/scout_apm/synchronous_recorder.rb#26
  def record!(request); end

  # source://scout_apm//lib/scout_apm/synchronous_recorder.rb#17
  def start; end

  # source://scout_apm//lib/scout_apm/synchronous_recorder.rb#22
  def stop; end
end

# source://scout_apm//lib/scout_apm/tasks/doctor.rb#2
module ScoutApm::Tasks; end

# source://scout_apm//lib/scout_apm/tasks/doctor.rb#3
class ScoutApm::Tasks::Doctor
  # @return [Doctor] a new instance of Doctor
  #
  # source://scout_apm//lib/scout_apm/tasks/doctor.rb#8
  def initialize; end

  # source://scout_apm//lib/scout_apm/tasks/doctor.rb#37
  def agent_context; end

  # source://scout_apm//lib/scout_apm/tasks/doctor.rb#50
  def configuration_settings; end

  # source://scout_apm//lib/scout_apm/tasks/doctor.rb#41
  def installed_instruments; end

  # source://scout_apm//lib/scout_apm/tasks/doctor.rb#64
  def log_details; end

  # source://scout_apm//lib/scout_apm/tasks/doctor.rb#11
  def run!; end

  class << self
    # source://scout_apm//lib/scout_apm/tasks/doctor.rb#4
    def run!; end
  end
end

# source://scout_apm//lib/scout_apm/tasks/support.rb#3
class ScoutApm::Tasks::Support
  # @return [Support] a new instance of Support
  #
  # source://scout_apm//lib/scout_apm/tasks/support.rb#9
  def initialize; end

  # source://scout_apm//lib/scout_apm/tasks/support.rb#13
  def run!; end

  class << self
    # source://scout_apm//lib/scout_apm/tasks/support.rb#4
    def run!; end
  end
end

# source://scout_apm//lib/scout_apm/tracer.rb#10
module ScoutApm::Tracer
  mixes_in_class_methods ::ScoutApm::Tracer::ClassMethods

  class << self
    # @private
    #
    # source://scout_apm//lib/scout_apm/tracer.rb#11
    def included(klass); end

    # Type: the Layer type - "View" or similar
    # Name: specific name - "users/_gravatar". The object must respond to "#to_s". This allows us to be more efficient - in most cases, the metric name isn't needed unless we are processing a slow transaction.
    # A Block: The code to be instrumented
    #
    # Options:
    # * :ignore_children - will not instrument any method calls beneath this call. Example use case: InfluxDB uses Net::HTTP, which is instrumented. However, we can provide more specific data if we know we're doing an influx call, so we'd rather just instrument the Influx call and ignore Net::HTTP.
    #   when rendering the transaction tree in the UI.
    # * :desc - Additional capture, SQL, or HTTP url or similar
    # * :scope - set to true if you want to make this layer a subscope
    #
    # source://scout_apm//lib/scout_apm/tracer.rb#24
    def instrument(type, name, options = T.unsafe(nil)); end
  end
end

# source://scout_apm//lib/scout_apm/tracer.rb#41
module ScoutApm::Tracer::ClassMethods
  # See ScoutApm::Tracer.instrument
  #
  # source://scout_apm//lib/scout_apm/tracer.rb#43
  def instrument(type, name, options = T.unsafe(nil), &block); end

  # Wraps a method in a call to #instrument via aggressive monkey patching.
  #
  # Options:
  # type - "View" or "ActiveRecord" and similar
  # name - "users/show", "App#find"
  #
  # source://scout_apm//lib/scout_apm/tracer.rb#52
  def instrument_method(method_name, options = T.unsafe(nil)); end

  private

  # source://scout_apm//lib/scout_apm/tracer.rb#74
  def _determine_instrumented_name(method_name, type); end

  # source://scout_apm//lib/scout_apm/tracer.rb#81
  def _find_unused_method_name; end

  # The method must exist to be instrumented.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracer.rb#115
  def _instrumentable?(method_name); end

  # +True+ if the method is already instrumented.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracer.rb#122
  def _instrumented?(instrumented_name, method_name); end

  # given a method and a metric, this method returns the traced
  # alias of the method name
  #
  # source://scout_apm//lib/scout_apm/tracer.rb#136
  def _instrumented_method_name(method_name, type); end

  # source://scout_apm//lib/scout_apm/tracer.rb#92
  def _instrumented_method_string(instrumented_name, uninstrumented_name, type, name, options = T.unsafe(nil)); end

  # Method names like +any?+ or +replace!+ contain a trailing character that would break when
  # eval'd as ? and ! aren't allowed inside method names.
  #
  # source://scout_apm//lib/scout_apm/tracer.rb#142
  def _sanitize_name(name); end

  # given a method and a metric, this method returns the
  # untraced alias of the method name
  #
  # source://scout_apm//lib/scout_apm/tracer.rb#130
  def _uninstrumented_method_name(method_name, type); end
end

# source://scout_apm//lib/scout_apm/tracked_request.rb#8
class ScoutApm::TrackedRequest
  # units = seconds
  #
  # @return [TrackedRequest] a new instance of TrackedRequest
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#59
  def initialize(agent_context, store); end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#442
  def acknowledge_children!; end

  # As we learn things about this request, we can add data here.
  # For instance, when we know where Rails routed this request to, we can store that scope info.
  # Or as soon as we know which URI it was directed at, we can store that.
  #
  # This data is internal to ScoutApm, to add custom information, use the Context api.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#263
  def annotate_request(hsh); end

  # As we go through a request, instrumentation can mark more general data into the Request
  # Known Keys:
  #   :uri - the full URI requested by the user
  #   :queue_latency - how long a background Job spent in the queue before starting processing
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#23
  def annotations; end

  # Grab backtraces more aggressively when running in dev trace mode
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#208
  def backtrace_threshold; end

  # This maintains a lookup hash of Layer names and call counts. It's used to trigger fetching a backtrace on n+1 calls.
  # Note that layer names might not be Strings - can alse be Utils::ActiveRecordMetricName. Also, this would fail for layers
  # with same names across multiple types.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#32
  def call_counts; end

  # This maintains a lookup hash of Layer names and call counts. It's used to trigger fetching a backtrace on n+1 calls.
  # Note that layer names might not be Strings - can alse be Utils::ActiveRecordMetricName. Also, this would fail for layers
  # with same names across multiple types.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#32
  def call_counts=(_arg0); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#162
  def capture_backtrace?(layer); end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#218
  def capture_mem_delta!; end

  # Context is application defined extra information.  (ie, which user, what
  # is their email/ip, what plan are they on, what locale are they using,
  # etc) See documentation for examples on how to set this from a
  # before_filter
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#13
  def context; end

  # Grab the currently running layer. Useful for adding additional data as we
  # learn it. This is useful in ActiveRecord instruments, where we start the
  # instrumentation early, and gradually learn more about the request that
  # actually happened as we go (for instance, the # of records found, or the
  # actual SQL generated).
  #
  # Returns nil in the case there is no current layer. That would be normal
  # for a completed TrackedRequest
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#157
  def current_layer; end

  # Ensure the background worker thread is up & running - a fallback if other
  # detection doesn't achieve this at boot.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#380
  def ensure_background_worker; end

  # This request had an exception.  Mark it down as an error
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#268
  def error!; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#272
  def error?; end

  # Are we finished with this request?
  # We're done if we have no layers left after popping one off
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#228
  def finalized?; end

  # Headers as recorded by rails
  # Can be nil if we never reach a Rails Controller
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#27
  def headers; end

  # Enable this when you would otherwise double track something interesting.
  # This came up when we implemented InfluxDB instrumentation, which is more
  # specific, and useful than the fact that InfluxDB happens to use Net::HTTP
  # internally
  #
  # When enabled, new layers won't be added to the current Request, and calls
  # to stop_layer will be ignored.
  #
  # Do not forget to turn if off when leaving a layer, it is the
  # instrumentation's task to do that.
  #
  # When you use this in code, be sure to use it in this order:
  #
  # start_layer
  # ignore_children
  #  -> call
  # acknowledge_children
  # stop_layer
  #
  # If you don't call it in this order, it's possible to get out of sync, and
  # have an ignored start and an actually-executed stop, causing layers to
  # get out of sync
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#438
  def ignore_children!; end

  # At any point in the request, calling code or instrumentation can call
  # `ignore_request!` to immediately stop recording any information about new
  # layers, and delete any existing layer info.  This class will still exist,
  # and respond to methods as normal, but `record!` won't be called, and no
  # data will be recorded.
  #
  # We still need to keep track of the current layer depth (via
  # "reported", and ready to be recreated for the next request.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#466
  def ignore_request!; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#448
  def ignoring_children?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#495
  def ignoring_recorded?; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#483
  def ignoring_request?; end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#487
  def ignoring_start_layer; end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#491
  def ignoring_stop_layer; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#280
  def instant?; end

  # if there's an instant_key, pass the transaction trace on for immediate reporting (in addition to the usual background aggregation)
  # this is set in the controller instumentation (ActionControllerRails3Rails4 according)
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#36
  def instant_key; end

  # if there's an instant_key, pass the transaction trace on for immediate reporting (in addition to the usual background aggregation)
  # this is set in the controller instumentation (ActionControllerRails3Rails4 according)
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#36
  def instant_key=(_arg0); end

  # This request is a job transaction iff it has a 'Job' layer
  # Use this only during recording
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#363
  def job?; end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#374
  def layer_finder; end

  # Returns +true+ if the total call time of AutoInstrument layers exceeds +AUTO_INSTRUMENT_TIMING_THRESHOLD+ and
  # records a Histogram of insignificant / significant layers by file name.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#190
  def layer_insignificant?(layer); end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#499
  def logger; end

  # This may be in bytes or KB based on the OSX. We store this as-is here and only do conversion to MB in Layer Converters.
  # XXX: Move this to environment?
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#214
  def mem_usage; end

  # If specified, an override for the name of the request. If unspecified,
  # the name is determined from the name of the Controller or Job layer.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#43
  def name_override; end

  # If specified, an override for the name of the request. If unspecified,
  # the name is determined from the name of the Controller or Job layer.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#43
  def name_override=(_arg0); end

  # Actually go fetch & make-real any lazily created data.
  # Clean up any cleverness in objects.
  # Makes this object ready to be Marshal Dumped (or otherwise serialized)
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#510
  def prepare_to_dump!; end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#140
  def real_request!; end

  # Have we seen a "controller" or "job" layer so far?
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#145
  def real_request?; end

  # Convert this request to the appropriate structure, then report it into
  # the peristent Store object
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#296
  def record!; end

  # Persist the Request
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#290
  def recorded!; end

  # Have we already persisted this request?
  # Used to know when we should just create a new one (don't attempt to add
  # data to an already-recorded request). See RequestManager
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#405
  def recorded?; end

  # An object that responds to `record!(TrackedRequest)` to store this tracked request
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#39
  def recorder; end

  # Go re-fetch the store based on what the Agent's official one is. Used
  # after hydrating a dumped TrackedRequest
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#519
  def restore_from_dump!; end

  # The first layer registered with this request. All other layers will be
  # children of this layer.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#17
  def root_layer; end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#276
  def set_headers(headers); end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#78
  def start_layer(layer); end

  # Run at the beginning of the whole request
  #
  # * Capture the first layer as the root_layer
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#235
  def start_request(layer); end

  # source://scout_apm//lib/scout_apm/tracked_request.rb#94
  def stop_layer; end

  # Run at the end of the whole request
  #
  # * Send the request off to be stored
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#242
  def stop_request; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#250
  def stopping?; end

  # A unique, but otherwise meaningless String to identify this request. UUID
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#46
  def transaction_id; end

  # Only call this after the request is complete
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#389
  def unique_name; end

  # Maintains a lookup Hash of call counts by layer name. Used to determine if we should capture a backtrace.
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#203
  def update_call_counts!(layer); end

  # This request is a web transaction iff it has a 'Controller' layer
  # Use this only during recording
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/tracked_request.rb#369
  def web?; end

  private

  # source://scout_apm//lib/scout_apm/tracked_request.rb#527
  def apply_name_override; end
end

# Layers of type 'AutoInstrument' are not recorded if their total_call_time doesn't exceed this threshold.
# AutoInstrument layers are frequently of short duration. This throws out this deadweight that is unlikely to be optimized.
#
# source://scout_apm//lib/scout_apm/tracked_request.rb#57
ScoutApm::TrackedRequest::AUTO_INSTRUMENT_TIMING_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://scout_apm//lib/scout_apm/tracked_request.rb#161
ScoutApm::TrackedRequest::BACKTRACE_BLACKLIST = T.let(T.unsafe(nil), Array)

# When we see these layers, it means a real request is going through the
# system. We toggle a flag to turn on some slightly more expensive
# instrumentation (backtrace collection and the like) that would be too
# expensive in situations where the framework is constantly churning. We
# see that on Sidekiq.
#
# source://scout_apm//lib/scout_apm/tracked_request.rb#53
ScoutApm::TrackedRequest::REQUEST_TYPES = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/transaction.rb#2
module ScoutApm::Transaction
  class << self
    # Ignores the current request
    #
    # source://scout_apm//lib/scout_apm/transaction.rb#4
    def ignore!; end

    # Renames the last Controller or Job layer
    #
    # source://scout_apm//lib/scout_apm/transaction.rb#9
    def rename(name); end
  end
end

# source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#2
class ScoutApm::TransactionTimeConsumed
  # @return [TransactionTimeConsumed] a new instance of TransactionTimeConsumed
  #
  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#13
  def initialize; end

  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#18
  def add(item, duration); end

  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#35
  def call_count_for(item); end

  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#23
  def percent_of_total(item); end

  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#31
  def total_time_for(item); end

  private

  # Private Accessor:
  # A hash of Endpoint Name to an time consumed record
  #
  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#5
  def endpoints; end

  # Private Accessor:
  # The total time spent across all endpoints
  #
  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#10
  def total_duration; end
end

# Time is in seconds
#
# source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#40
class ScoutApm::TransactionTimeConsumed::TotalTimeRecord < ::Struct
  # @return [TotalTimeRecord] a new instance of TotalTimeRecord
  #
  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#41
  def initialize; end

  # source://scout_apm//lib/scout_apm/transaction_time_consumed.rb#45
  def add(duration); end

  # Returns the value of attribute count
  #
  # @return [Object] the current value of count
  def count; end

  # Sets the attribute count
  #
  # @param value [Object] the value to set the attribute count to.
  # @return [Object] the newly set value
  def count=(_); end

  # Returns the value of attribute total_duration
  #
  # @return [Object] the current value of total_duration
  def total_duration; end

  # Sets the attribute total_duration
  #
  # @param value [Object] the value to set the attribute total_duration to.
  # @return [Object] the newly set value
  def total_duration=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#8
module ScoutApm::Utils; end

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#3
class ScoutApm::Utils::ActiveRecordMetricName
  # @return [ActiveRecordMetricName] a new instance of ActiveRecordMetricName
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#7
  def initialize(sql, name); end

  # For the layer lookup.
  # Reminder: #eql? is for Hash equality: returns true if obj and other refer to the same hash key.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#48
  def ==(o); end

  # For the layer lookup.
  # Reminder: #eql? is for Hash equality: returns true if obj and other refer to the same hash key.
  #
  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#48
  def eql?(o); end

  # For the layer lookup.
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#41
  def hash; end

  # This only returns a value if a name is provided via +initialize+.
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#31
  def model; end

  # Returns the value of attribute name.
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#4
  def name; end

  # This only returns a value if a name is provided via +initialize+.
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#36
  def normalized_operation; end

  # Returns the value of attribute sql.
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#4
  def sql; end

  # Converts an SQL string and the name (typically assigned automatically
  # by rails) into a Scout metric_name.
  #
  # This prefers to use the ActiveRecord-provided name over parsing SQL as parsing is slower.
  #
  # sql: SELECT "places".* FROM "places"  ORDER BY "places"."position" ASC
  # name: Place Load
  # metric_name: Place/find
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#20
  def to_s; end

  private

  # This only returns a value if a name is provided via +initialize+.
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#58
  def operation; end

  # Returns nil if no match
  # Returns nil if the operation wasn't under developer control (and hence isn't interesting to report)
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#71
  def parse_operation; end

  # This only returns a value if a name is provided via +initialize+.
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#65
  def parts; end

  # Attempt to do some basic parsing of SQL via regexes to extract the SQL
  # verb (select, update, etc) and the table being operated on.
  #
  # This is a fallback from what ActiveRecord gives us, we prefer its
  # names. But sometimes it is giving us a no-name query, and we have to
  # attempt to figure it out ourselves.
  #
  # This relies on ActiveSupport's classify method. If it's not present,
  # just skip the attempt to rename here. This could happen in a Grape or
  # Sinatra application that doesn't import ActiveSupport. At this point,
  # you're already using ActiveRecord, so it's likely loaded anyway.
  #
  # source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#122
  def regex_name(sql); end
end

# BEGIN is a reserved keyword
#
# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#96
ScoutApm::Utils::ActiveRecordMetricName::BEGIN_STATEMENT = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#97
ScoutApm::Utils::ActiveRecordMetricName::COMMIT = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#95
ScoutApm::Utils::ActiveRecordMetricName::COUNT = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#104
ScoutApm::Utils::ActiveRecordMetricName::COUNT_LABEL = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#5
ScoutApm::Utils::ActiveRecordMetricName::DEFAULT_METRIC = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#108
ScoutApm::Utils::ActiveRecordMetricName::DELETE_LABEL = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#102
ScoutApm::Utils::ActiveRecordMetricName::DELETE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#91
ScoutApm::Utils::ActiveRecordMetricName::FROM = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#107
ScoutApm::Utils::ActiveRecordMetricName::INSERT_LABEL = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#101
ScoutApm::Utils::ActiveRecordMetricName::INSERT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#92
ScoutApm::Utils::ActiveRecordMetricName::INTO = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#93
ScoutApm::Utils::ActiveRecordMetricName::NON_GREEDY_CONSUME = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#90
ScoutApm::Utils::ActiveRecordMetricName::REGEX_OPERATION = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#105
ScoutApm::Utils::ActiveRecordMetricName::SELECT_LABEL = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#99
ScoutApm::Utils::ActiveRecordMetricName::SELECT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#94
ScoutApm::Utils::ActiveRecordMetricName::TABLE = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#109
ScoutApm::Utils::ActiveRecordMetricName::UNKNOWN_LABEL = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#106
ScoutApm::Utils::ActiveRecordMetricName::UPDATE_LABEL = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#100
ScoutApm::Utils::ActiveRecordMetricName::UPDATE_REGEX = T.let(T.unsafe(nil), Regexp)

# Regex based naming  #
#
# source://scout_apm//lib/scout_apm/utils/active_record_metric_name.rb#89
ScoutApm::Utils::ActiveRecordMetricName::WHITE_SPACE = T.let(T.unsafe(nil), String)

# source://scout_apm//lib/scout_apm/utils/backtrace_parser.rb#8
class ScoutApm::Utils::BacktraceParser
  # call_stack - an +Array+ of calls, typically generated via the +caller+ method.
  # Example single line:
  # "/Users/dlite/.rvm/rubies/ruby-2.4.5/lib/ruby/2.4.0/irb/workspace.rb:87:in `eval'"
  #
  # @return [BacktraceParser] a new instance of BacktraceParser
  #
  # source://scout_apm//lib/scout_apm/utils/backtrace_parser.rb#17
  def initialize(call_stack, root = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/utils/backtrace_parser.rb#26
  def call; end

  # Returns the value of attribute call_stack.
  #
  # source://scout_apm//lib/scout_apm/utils/backtrace_parser.rb#12
  def call_stack; end
end

# will return this many backtrace frames from the app stack.
#
# source://scout_apm//lib/scout_apm/utils/backtrace_parser.rb#10
ScoutApm::Utils::BacktraceParser::APP_FRAMES = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#3
class ScoutApm::Utils::Error < ::StandardError; end

# A simple wrapper around Ruby's built-in gzip support.
#
# source://scout_apm//lib/scout_apm/utils/gzip_helper.rb#4
class ScoutApm::Utils::GzipHelper
  # @return [GzipHelper] a new instance of GzipHelper
  #
  # source://scout_apm//lib/scout_apm/utils/gzip_helper.rb#9
  def initialize(level = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/utils/gzip_helper.rb#13
  def deflate(str); end

  # Returns the value of attribute level.
  #
  # source://scout_apm//lib/scout_apm/utils/gzip_helper.rb#7
  def level; end
end

# source://scout_apm//lib/scout_apm/utils/gzip_helper.rb#5
ScoutApm::Utils::GzipHelper::DEFAULT_GZIP_LEVEL = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/utils/installed_gems.rb#3
class ScoutApm::Utils::InstalledGems
  # @return [InstalledGems] a new instance of InstalledGems
  #
  # source://scout_apm//lib/scout_apm/utils/installed_gems.rb#6
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://scout_apm//lib/scout_apm/utils/installed_gems.rb#4
  def context; end

  # source://scout_apm//lib/scout_apm/utils/installed_gems.rb#10
  def logger; end

  # source://scout_apm//lib/scout_apm/utils/installed_gems.rb#14
  def run; end
end

# source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#5
class ScoutApm::Utils::InstanceVar
  # @return [InstanceVar] a new instance of InstanceVar
  #
  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#9
  def initialize(name, obj, parent); end

  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#19
  def history; end

  # Returns the value of attribute name.
  #
  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#6
  def name; end

  # Returns the value of attribute obj.
  #
  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#7
  def obj; end

  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#15
  def to_s; end
end

# source://scout_apm//lib/scout_apm/utils/klass_helper.rb#3
module ScoutApm::Utils::KlassHelper
  class << self
    # KlassHelper.defined?("ActiveRecord", "Base") #=> true / false
    # KlassHelper.defined?("ActiveRecord::Base")   #=> true / false
    #
    # @return [Boolean]
    #
    # source://scout_apm//lib/scout_apm/utils/klass_helper.rb#7
    def defined?(*names); end

    # KlassHelper.lookup("ActiveRecord::Base") => ActiveRecord::Base
    # KlassHelper.lookup("ActiveRecord::SomethingThatDoesNotExist") => :missing_class
    #
    # source://scout_apm//lib/scout_apm/utils/klass_helper.rb#13
    def lookup(*names); end
  end
end

# source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#24
class ScoutApm::Utils::MarshalLogging
  # @return [MarshalLogging] a new instance of MarshalLogging
  #
  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#25
  def initialize(base_obj); end

  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#29
  def dive; end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#78
  def dumps?(obj); end

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/utils/marshal_logging.rb#85
  def offending_hash?(obj); end
end

# source://scout_apm//lib/scout_apm/utils/numbers.rb#3
class ScoutApm::Utils::Numbers
  class << self
    # Round a float to a certain number of decimal places
    #
    # source://scout_apm//lib/scout_apm/utils/numbers.rb#6
    def round(number, decimals); end
  end
end

# source://scout_apm//lib/scout_apm/utils/scm.rb#4
class ScoutApm::Utils::Scm
  class << self
    # Takes an *already relative* path +path+
    # Returns a relative path, prepending the configured +scm_subdirectory+ environment string
    #
    # source://scout_apm//lib/scout_apm/utils/scm.rb#7
    def relative_scm_path(path, scm_subdirectory = T.unsafe(nil)); end
  end
end

# Represents a random ID that we can use to track a certain span. The
# `span` prefix is only for ease of reading logs - it should not be
# interpreted to convey any sort of meaning.
#
# source://scout_apm//lib/scout_apm/utils/unique_id.rb#31
class ScoutApm::Utils::SpanId
  # @return [SpanId] a new instance of SpanId
  #
  # source://scout_apm//lib/scout_apm/utils/unique_id.rb#32
  def initialize; end

  # source://scout_apm//lib/scout_apm/utils/unique_id.rb#36
  def to_s; end
end

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#9
class ScoutApm::Utils::SqlSanitizer
  # @return [SqlSanitizer] a new instance of SqlSanitizer
  #
  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#44
  def initialize(sql); end

  # Returns the value of attribute database_engine.
  #
  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#42
  def database_engine; end

  # Sets the attribute database_engine
  #
  # @param value the value to set the attribute database_engine to.
  #
  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#42
  def database_engine=(_arg0); end

  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#50
  def sql; end

  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#54
  def to_s; end

  private

  # @return [Boolean]
  #
  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#113
  def has_encodings?(encodings = T.unsafe(nil)); end

  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#119
  def scrubbed(str); end

  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#93
  def to_s_mysql; end

  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#78
  def to_s_postgres; end

  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#104
  def to_s_sqlite; end

  # source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#70
  def to_s_sqlserver; end
end

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#117
ScoutApm::Utils::SqlSanitizer::MAX_SQL_LENGTH = T.let(T.unsafe(nil), Integer)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#11
ScoutApm::Utils::SqlSanitizer::MULTIPLE_QUESTIONS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#10
ScoutApm::Utils::SqlSanitizer::MULTIPLE_SPACES = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#30
ScoutApm::Utils::SqlSanitizer::MYSQL_IN_CLAUSE = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#29
ScoutApm::Utils::SqlSanitizer::MYSQL_REMOVE_DOUBLE_QUOTE_STRINGS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#27
ScoutApm::Utils::SqlSanitizer::MYSQL_REMOVE_INTEGERS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#28
ScoutApm::Utils::SqlSanitizer::MYSQL_REMOVE_SINGLE_QUOTE_STRINGS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#26
ScoutApm::Utils::SqlSanitizer::MYSQL_VAR_INTERPOLATION = T.let(T.unsafe(nil), Regexp)

# Should be everything between a FROM and a WHERE
#
# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#20
ScoutApm::Utils::SqlSanitizer::PSQL_AFTER_FROM = T.let(T.unsafe(nil), Regexp)

# Should be everything between a FROM and AS without WHERE
#
# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#21
ScoutApm::Utils::SqlSanitizer::PSQL_AFTER_FROM_AS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#22
ScoutApm::Utils::SqlSanitizer::PSQL_AFTER_JOIN = T.let(T.unsafe(nil), Regexp)

# Should be everything between a FROM and a WHERE
#
# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#17
ScoutApm::Utils::SqlSanitizer::PSQL_AFTER_SELECT = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#24
ScoutApm::Utils::SqlSanitizer::PSQL_AFTER_SET = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#23
ScoutApm::Utils::SqlSanitizer::PSQL_AFTER_WHERE = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#19
ScoutApm::Utils::SqlSanitizer::PSQL_IN_CLAUSE = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#18
ScoutApm::Utils::SqlSanitizer::PSQL_PLACEHOLDER = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#16
ScoutApm::Utils::SqlSanitizer::PSQL_REMOVE_INTEGERS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#15
ScoutApm::Utils::SqlSanitizer::PSQL_REMOVE_JSON_STRINGS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#14
ScoutApm::Utils::SqlSanitizer::PSQL_REMOVE_STRINGS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#13
ScoutApm::Utils::SqlSanitizer::PSQL_VAR_INTERPOLATION = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#34
ScoutApm::Utils::SqlSanitizer::SQLITE_REMOVE_INTEGERS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#33
ScoutApm::Utils::SqlSanitizer::SQLITE_REMOVE_STRINGS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#32
ScoutApm::Utils::SqlSanitizer::SQLITE_VAR_INTERPOLATION = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#40
ScoutApm::Utils::SqlSanitizer::SQLSERVER_IN_CLAUSE = T.let(T.unsafe(nil), Regexp)

# => "EXEC sp_executesql N'SELECT  [users].* FROM [users] WHERE (age > 50)  ORDER BY [users].[id] ASC OFFSET 0 ROWS FETCH NEXT @0 ROWS ONLY', N'@0 int', @0 = 10"
#
# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#37
ScoutApm::Utils::SqlSanitizer::SQLSERVER_REMOVE_EXECUTESQL = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#39
ScoutApm::Utils::SqlSanitizer::SQLSERVER_REMOVE_INTEGERS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/sql_sanitizer.rb#38
ScoutApm::Utils::SqlSanitizer::SQLSERVER_REMOVE_STRINGS = T.let(T.unsafe(nil), Regexp)

# source://scout_apm//lib/scout_apm/utils/time.rb#3
class ScoutApm::Utils::Time
  class << self
    # Handles both integer (unix) time and Time objects
    # example output:  "09/10/15 04:34:28 -0600"
    #
    # source://scout_apm//lib/scout_apm/utils/time.rb#6
    def to_s(time); end
  end
end

# Represents a random ID that we can use to track a certain transaction.
# The `trans` prefix is only for ease of reading logs - it should not be
# interpreted to convey any sort of meaning.
#
# source://scout_apm//lib/scout_apm/utils/unique_id.rb#18
class ScoutApm::Utils::TransactionId
  # @return [TransactionId] a new instance of TransactionId
  #
  # source://scout_apm//lib/scout_apm/utils/unique_id.rb#19
  def initialize; end

  # source://scout_apm//lib/scout_apm/utils/unique_id.rb#23
  def to_s; end
end

# source://scout_apm//lib/scout_apm/utils/unique_id.rb#3
class ScoutApm::Utils::UniqueId
  class << self
    # source://scout_apm//lib/scout_apm/utils/unique_id.rb#6
    def simple(length = T.unsafe(nil)); end
  end
end

# source://scout_apm//lib/scout_apm/utils/unique_id.rb#4
ScoutApm::Utils::UniqueId::ALPHABET = T.let(T.unsafe(nil), Array)

# source://scout_apm//lib/scout_apm/version.rb#2
ScoutApm::VERSION = T.let(T.unsafe(nil), String)
